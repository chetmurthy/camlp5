

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Parsing tools &mdash; Camlp5 7.10 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Camlp5 7.10 documentation" href="index.html"/>
        <link rel="next" title="Printing tools" href="prtools.html"/>
        <link rel="prev" title="Parsing and Printing tools" href="pptools.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Camlp5
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="strict.html">Transitional and Strict modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="pptools.html">Parsing and Printing tools</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Parsing tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#stream-parsers">Stream parsers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#streams">Streams</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#stream-from">Stream.from</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stream-of-list">Stream.of_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stream-of-string">Stream.of_string</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stream-of-channel">Stream.of_channel</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#semantics-of-parsers">Semantics of parsers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parser">Parser</a></li>
<li class="toctree-l4"><a class="reference internal" href="#left-factorization">Left factorization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#match-with-parser">Match with parser</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-messages">Error messages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stream-pattern-component">Stream pattern component</a></li>
<li class="toctree-l4"><a class="reference internal" href="#let-statement">Let statement</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lookahead">Lookahead</a></li>
<li class="toctree-l4"><a class="reference internal" href="#no-error-optimization">No error optimization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#position">Position</a></li>
<li class="toctree-l4"><a class="reference internal" href="#semantic-action">Semantic action</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#remarks">Remarks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simplicity-vs-associativity">Simplicity vs Associativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lexing-vs-parsing">Lexing vs Parsing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lexer-syntax-vs-parser-syntax">Lexer syntax vs Parser syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#purely-functional-parsers">Purely functional parsers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#stream-lexers">Stream lexers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semantics">Semantics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#symbols">Symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specific-expressions">Specific expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">Lookahead</a></li>
<li class="toctree-l4"><a class="reference internal" href="#semantic-actions-of-rules">Semantic actions of rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#a-complete-example">A complete example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compiling">Compiling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-to-display-the-generated-code">How to display the generated code</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functional-parsers">Functional parsers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Streams</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fstream-from">Fstream.from</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fstream-of-list">Fstream.of_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fstream-of-string">Fstream.of_string</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fstream-of-channel">Fstream.of_channel</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id6">Semantics of parsers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fparser">Fparser</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-position">Error position</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#backtracking-parsers">Backtracking parsers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">Semantics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#algorithm">Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type">Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#syntax-errors">Syntax errors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#extensible-grammars">Extensible grammars</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#getting-started">Getting started</a></li>
<li class="toctree-l3"><a class="reference internal" href="#syntax-of-the-extend-statement">Syntax of the EXTEND statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semantics-of-the-extend-statement">Semantics of the EXTEND statement</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#global-indicator">GLOBAL indicator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#entries-list">Entries list</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#optional-position">Optional position</a></li>
<li class="toctree-l5"><a class="reference internal" href="#levels">Levels</a></li>
<li class="toctree-l5"><a class="reference internal" href="#rules">Rules</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id9">Symbols</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#meta-symbols">Meta symbols</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id10">Type</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#rules-insertion">Rules insertion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">Semantic action</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-delete-rule-statement">The DELETE_RULE statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extensions-fold0-and-fold1">Extensions FOLD0 and FOLD1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grammar-machinery">Grammar machinery</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#start-and-continue">Start and Continue</a></li>
<li class="toctree-l4"><a class="reference internal" href="#associativity">Associativity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parsing-algorithm">Parsing algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#errors-and-recovery">Errors and recovery</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tokens-starting-rules">Tokens starting rules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interface-with-the-lexer">Interface with the lexer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#token-patterns">Token patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-lexer-record">The lexer record</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#tok-func"><code class="docutils literal"><span class="pre">tok_func</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#tok-using"><code class="docutils literal"><span class="pre">tok_using</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#tok-removing"><code class="docutils literal"><span class="pre">tok_removing</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#tok-match"><code class="docutils literal"><span class="pre">tok_match</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#tok-text"><code class="docutils literal"><span class="pre">tok_text</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#tok-comm"><code class="docutils literal"><span class="pre">tok_comm</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#minimalist-version">Minimalist version</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functorial-interface">Functorial interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-lexer-type">The lexer type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-functor-parameter">The functor parameter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-resulting-grammar-module">The resulting grammar module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gextend-and-gdelete-rule">GEXTEND and GDELETE_RULE</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#an-example-arithmetic-calculator">An example: arithmetic calculator</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="prtools.html">Printing tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="langext.html">Language Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Appendix</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Camlp5</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Parsing tools</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/patools.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="parsing-tools">
<h1>Parsing tools<a class="headerlink" href="#parsing-tools" title="Permalink to this headline">¶</a></h1>
<div class="section" id="stream-parsers">
<span id="parsers"></span><h2>Stream parsers<a class="headerlink" href="#stream-parsers" title="Permalink to this headline">¶</a></h2>
<p>We describe here the syntax and the semantics of the parsers of
streams of Camlp5. Streams are kinds of lazy lists. The parsers of
these streams use recursive descendent method without backtracking,
which is the most natural one in functional languages. In particular,
parsers are normal functions.</p>
<p>Notice that the parsers have existed in OCaml since many years (the
beginning of the 90ies), but some new features have been added in 2007
(lookahead, “no error” optimization, let..in statement and left
factorization) in Camlp5 distribution. This chapter describes them
also.</p>
<div class="section" id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>Parsers apply to values of type <code class="docutils literal"><span class="pre">Stream.t</span></code> defined in the module
<code class="docutils literal"><span class="pre">Stream</span></code> of the standard library of OCaml. Like the type <code class="docutils literal"><span class="pre">list</span></code>, the
type <code class="docutils literal"><span class="pre">Stream.t</span></code> has a type parameter, indicating the type of its
elements. They differ from the lists that they are lazy (the elements
are evaluated as long as the parser need them for its actions), and
imperative (parsers deletes their first elements when they take their
parsing decisions): notice that purely functional parsers exist in
Camlp5, where the corresponding streams are lazy and functional, the
analyzed elements remaining in the initial stream and the semantic
action returning the resulting stream together with the normal result,
which allow natural limited backtrack but have the drawback that it is
not easy to find the position of parsing errors when they happen.</p>
<p>Parsers of lazy+imperative streams, which are described here, use a
method named “recursive descendent”: they look at the first element,
they decide what to do in function of its value, and continue the
parsing with the remaining elements. Parsers can call other parsers,
and can be recursive, like normal functions.</p>
<p>Actually, parsers are just pure syntactic sugar. When writing a parser
in the syntax of the parser, Camlp5 transforms them into normal call
to functions, use of patterns matchings and try..with statements.  The
pretty printer of Camlp5, by default, displays this expanded result,
without syntax of parsers. A pretty printing kit, when added, can
rebuild the parsers in their initial syntax and display it.</p>
</div>
<div class="section" id="syntax">
<h3>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>The syntax of the parsers, when loading “pa_rp.cmo” (or already</dt>
<dd>included in the command “camlp5r”), is the following:</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span>          <span class="n">expression</span> <span class="p">::</span><span class="o">=</span> <span class="n">parser</span>
                       <span class="o">|</span> <span class="n">match</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">parser</span>
              <span class="n">parser</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;parser&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;[&quot;</span> <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="s2">&quot;]&quot;</span>
                       <span class="o">|</span> <span class="s2">&quot;parser&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="n">parser</span><span class="o">-</span><span class="n">case</span>
   <span class="n">match</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">parser</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;match&quot;</span> <span class="n">expression</span> <span class="s2">&quot;with&quot;</span> <span class="n">parser</span>
        <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="p">::</span><span class="o">=</span> <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="n">parser</span><span class="o">-</span><span class="n">case</span>
                       <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
         <span class="n">parser</span><span class="o">-</span><span class="n">case</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;[:&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span> <span class="s2">&quot;:]&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="n">expression</span>
      <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span> <span class="p">::</span><span class="o">=</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span>
                       <span class="o">|</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="s2">&quot;;&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">cont</span>
                       <span class="o">|</span> <span class="s2">&quot;let&quot;</span> <span class="n">LIDENT</span> <span class="s2">&quot;=&quot;</span> <span class="n">expression</span> <span class="s2">&quot;in&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span>
                       <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
    <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">cont</span> <span class="p">::</span><span class="o">=</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span><span class="o">-</span><span class="n">err</span>
                       <span class="o">|</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span><span class="o">-</span><span class="n">err</span> <span class="s2">&quot;;&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">cont</span>
                       <span class="o">|</span> <span class="s2">&quot;let&quot;</span> <span class="n">LIDENT</span> <span class="s2">&quot;=&quot;</span> <span class="n">expression</span> <span class="s2">&quot;in&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">cont</span>
<span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span><span class="o">-</span><span class="n">err</span> <span class="p">::</span><span class="o">=</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span>
                       <span class="o">|</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="s2">&quot;?&quot;</span> <span class="n">expression</span>
                       <span class="o">|</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="s2">&quot;!&quot;</span>
    <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;`&quot;</span> <span class="n">pattern</span>
                       <span class="o">|</span> <span class="s2">&quot;`&quot;</span> <span class="n">pattern</span> <span class="s2">&quot;when&quot;</span> <span class="n">expression</span>
                       <span class="o">|</span> <span class="s2">&quot;?=&quot;</span> <span class="n">lookaheads</span>
                       <span class="o">|</span> <span class="n">pattern</span> <span class="s2">&quot;=&quot;</span> <span class="n">expression</span>
                       <span class="o">|</span> <span class="n">pattern</span>
          <span class="n">lookaheads</span> <span class="p">::</span><span class="o">=</span> <span class="n">lookaheads</span> <span class="s2">&quot;|&quot;</span> <span class="n">lookahead</span>
                       <span class="o">|</span> <span class="n">lookahead</span>
           <span class="n">lookahead</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="n">patterns</span> <span class="s2">&quot;]&quot;</span>
            <span class="n">patterns</span> <span class="p">::</span><span class="o">=</span> <span class="n">patterns</span> <span class="n">pattern</span>
                       <span class="o">|</span> <span class="n">pattern</span>
             <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="p">::</span><span class="o">=</span> <span class="n">pattern</span>
                       <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="streams">
<h3>Streams<a class="headerlink" href="#streams" title="Permalink to this headline">¶</a></h3>
<p>The parsers are functions taking streams as parameter. Streams are are
values of type <code class="docutils literal"><span class="pre">Stream.t</span> <span class="pre">a</span></code> for some type <code class="docutils literal"><span class="pre">a&lt;</span></code>. It is possible to
build streams using the functions defined in the module
<code class="docutils literal"><span class="pre">Stream</span></code>:</p>
<div class="section" id="stream-from">
<h4>Stream.from<a class="headerlink" href="#stream-from" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">Stream.from</span> <span class="pre">f</span></code> returns a stream built from the function <code class="docutils literal"><span class="pre">f</span></code>. To
create a new stream element, the function <code class="docutils literal"><span class="pre">f</span></code> is called with the
current stream count, starting with zero. The user function <code class="docutils literal"><span class="pre">f</span></code> must
return either <code class="docutils literal"><span class="pre">Some</span> <span class="pre">&lt;value&gt;</span></code> for a value or <code class="docutils literal"><span class="pre">None</span></code> to specify the
end of the stream.</p>
</div>
<div class="section" id="stream-of-list">
<h4>Stream.of_list<a class="headerlink" href="#stream-of-list" title="Permalink to this headline">¶</a></h4>
<p>Return a stream built from the list in the same order.</p>
</div>
<div class="section" id="stream-of-string">
<h4>Stream.of_string<a class="headerlink" href="#stream-of-string" title="Permalink to this headline">¶</a></h4>
<p>Return a stream of the characters of the string parameter.</p>
</div>
<div class="section" id="stream-of-channel">
<h4>Stream.of_channel<a class="headerlink" href="#stream-of-channel" title="Permalink to this headline">¶</a></h4>
<p>Return a stream of the characters read from the input channel
parameter.</p>
</div>
</div>
<div class="section" id="semantics-of-parsers">
<h3>Semantics of parsers<a class="headerlink" href="#semantics-of-parsers" title="Permalink to this headline">¶</a></h3>
<div class="section" id="parser">
<h4>Parser<a class="headerlink" href="#parser" title="Permalink to this headline">¶</a></h4>
<p>A parser, defined with the syntax “parser” above, is of type
<code class="docutils literal"><span class="pre">Stream.t</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> where <code class="docutils literal"><span class="pre">a</span></code> is the type of the elements
of the streams and <code class="docutils literal"><span class="pre">b</span></code> the type of the result. The parser cases are
tested in the order they are defined until one of them applies. The
result is the semantic action of the parser case which applies. If no
parser case applies, the exception <code class="docutils literal"><span class="pre">Stream.Failure</span></code> is
raised.</p>
<p>When testing a parser case, if the first stream pattern component
matches, all remaining stream pattern components of the stream pattern
must match also. If one does not match, the parser raises the
exception <code class="docutils literal"><span class="pre">Stream.Error</span></code> which has a parameter of type
string: by default, this string is the empty string, but if the stream
pattern component which does not match is followed by a question mark
and an expression, this expression is evaluated and given as parameter
to <code class="docutils literal"><span class="pre">Stream.Error</span></code>.</p>
<p>In short, a parser can return with three ways:</p>
<ul class="simple">
<li>A normal result, of type <code class="docutils literal"><span class="pre">b</span></code> for a parser of type <code class="docutils literal"><span class="pre">Stream.t</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>.</li>
<li>Raising the exception <code class="docutils literal"><span class="pre">Stream.Failure</span></code>.</li>
<li>Raising the exception <code class="docutils literal"><span class="pre">Stream.Error</span></code>.</li>
</ul>
<p>Fundamentally, the exception <code class="docutils literal"><span class="pre">Stream.Failure</span></code> means “this
parser does not apply and no element have been removed from the
initial stream”. This is a normal case when parsing: the parser
locally fails, but the parsing can continue.</p>
<p>Conversely, the exception <code class="docutils literal"><span class="pre">Stream.Error</span></code> means that “this
parser encountered a syntax error and elements have probably been
removed from the stream”. In this case, there is no way to recover the
parsing, and it definitively fails.</p>
</div>
<div class="section" id="left-factorization">
<h4>Left factorization<a class="headerlink" href="#left-factorization" title="Permalink to this headline">¶</a></h4>
<p>In parsers, <em>consecutive</em> rules starting with the same components are
left factorized. It means that they are transformed into one only rule
starting with the common path, and continuing with a call to a parser
separating the two cases. The order is kept, except that the possible
empty rule is inserted at the end.</p>
<p>For example, the parser::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
[ [: `If; e1 = expr; `Then; e2 = expr; `Else; e3 = expr :] -&gt; f e1 e2 e3
| [: `If; e1 = expr; `Then; e2 = expr :] -&gt; g e1 e2 ]
</pre></div>
</div>
<p>is transformed into::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
  [: `If; e1 = expr; `Then; e2 = expr;
     a =
       parser
       [ [: `Else; e3 = expr :] -&gt; f e1 e2 e3
       | [: :] -&gt; g e1 e2 ] :] -&gt; a
</pre></div>
</div>
<p>The version where rules are inverted::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
[ [: `If; e1 = expr; `Then; e2 = expr :] -&gt; g e1 e2
| [: `If; e1 = expr; `Then; e2 = expr; `Else; e3 = expr :] -&gt; f e1 e2 e3 ]
</pre></div>
</div>
<p>is transformed into the same parser.</p>
<p>Notice that:</p>
<ul class="simple">
<li>Only <em>consecutive</em> rules are left factorized. In the following parser:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
[ [: `If; e1 = expr; `Then; e2 = expr; `Else; e3 = expr :] -&gt; ...
| [: a = b :] -&gt; a
| [: `If; e1 = expr; `Then; e2 = expr :] -&gt; ... ]
</pre></div>
</div>
<p>the two rules starting with <code class="docutils literal"><span class="pre">`If</span></code> are not left factorized,
and the second <code class="docutils literal"><span class="pre">`If</span></code> rule will never work.</p>
<ul class="simple">
<li>The components which are not <em>identical</em> are not factorized. In the following parser:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
[ [: `If; e1 = expr; `Then; e2 = expr; `Else; e3 = expr :] -&gt; ...
| [: `If; e4 = expr; `Then; e2 = expr :] -&gt; ... ]
</pre></div>
</div>
<p>only the first component, <code class="docutils literal"><span class="pre">`If</span></code> is factorized, the second one being
different because of different patterns (<code class="docutils literal"><span class="pre">e1</span></code> and <code class="docutils literal"><span class="pre">e4</span></code>).</p>
</div>
<div class="section" id="match-with-parser">
<h4>Match with parser<a class="headerlink" href="#match-with-parser" title="Permalink to this headline">¶</a></h4>
<p>The syntax <code class="docutils literal"><span class="pre">match</span> <span class="pre">expression</span> <span class="pre">with</span> <span class="pre">parser</span></code> allows to match a stream
against a parser. It is, for <code class="docutils literal"><span class="pre">parser</span></code>, the equivalent of <code class="docutils literal"><span class="pre">match</span>
<span class="pre">expression</span> <span class="pre">with</span></code> for <code class="docutils literal"><span class="pre">fun</span></code>. The same way we could say::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="n">expression</span> <span class="k">with</span> <span class="o">...</span>
</pre></div>
</div>
<p>could be considered as an equivalent to::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">fun</span> <span class="o">...</span><span class="p">)</span> <span class="n">expression</span>
</pre></div>
</div>
<p>we could consider that::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="n">expression</span> <span class="k">with</span> <span class="n">parser</span> <span class="o">...</span>
</pre></div>
</div>
<p>is an equivalent to::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">parser</span> <span class="o">...</span><span class="p">)</span> <span class="n">expression</span>
</pre></div>
</div>
</div>
<div class="section" id="error-messages">
<h4>Error messages<a class="headerlink" href="#error-messages" title="Permalink to this headline">¶</a></h4>
<p>A <code class="docutils literal"><span class="pre">Stream.Error</span></code> exception is raised when a stream pattern component
does not match and that it is not the first one of the parser
case. This exception has a parameter of type <code class="docutils literal"><span class="pre">string</span></code>, useful to specify
the error message. By default, this is the empty string. To specify an
error message, add a question mark and an expression after the stream
pattern component. A typical error message is “that stream pattern
component expected”.  Example with the parser of <code class="docutils literal"><span class="pre">if..then..else..</span></code>
above::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
  [: `If; e1 = expr ? &quot;expression expected after &#39;if&#39;&quot;;
     `Then ? &quot;&#39;then&#39; expected&quot;;
     e2 = expr ? &quot;expression expected after &#39;then&#39;&quot;;
     a =
       parser
       [ [: `Else; e3 = expr ? &quot;expression expected&quot; :] -&gt; f e1 e2 e3
       | [: :] -&gt; g e1 e2 ] :] -&gt; a
</pre></div>
</div>
<p>Notice that the expression after the question mark is evaluated only
in case of syntax error. Therefore, it can be a complicated call to a
complicated function without slowing down the normal parsing.</p>
</div>
<div class="section" id="stream-pattern-component">
<h4>Stream pattern component<a class="headerlink" href="#stream-pattern-component" title="Permalink to this headline">¶</a></h4>
<p>In a stream pattern (starting with <code class="docutils literal"><span class="pre">[:</span></code> and ending with
<code class="docutils literal"><span class="pre">:]</span></code>), the stream pattern components are separated with
the semicolon character. There are three cases of stream pattern
components with some sub-cases for some of them, and an extra syntax
can be used with a <code class="docutils literal"><span class="pre">let..in</span></code> construction. The three cases are:</p>
<ul>
<li><p class="first">A direct test of one or several stream elements (called <strong>terminal</strong>
symbol), in three ways:</p>
<ul class="simple">
<li>The character “backquote” followed by a pattern, meaning: if the
stream starts with an element which is matched by this pattern,
the stream pattern component matches, and the stream element is
removed from the stream.</li>
<li>The character “backquote” followed by a pattern, the keyword
<code class="docutils literal"><span class="pre">when</span></code> and an expression of type <code class="docutils literal"><span class="pre">bool</span></code>, meaning: if
the stream starts with an element which is matched by this pattern
and if the evaluation of the expression is <code class="docutils literal"><span class="pre">True</span></code>,
the stream pattern component matches, and the first element of the
stream is removed.</li>
<li>The character “question mark” followed by the character “equal”
and a lookahead expression (see further), meaning: if the
lookahead applies, the stream pattern component matches. The
lookahead may unfreeze one or several elements on the stream, but
does not remove them.</li>
</ul>
</li>
<li><p class="first">A pattern followed by the “equal” sign and an expression of type
<code class="docutils literal"><span class="pre">Stream.t</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">y</span></code> for some types <code class="docutils literal"><span class="pre">x</span></code> and
<code class="docutils literal"><span class="pre">y</span></code>. This expression is called a <strong>non terminal</strong>
symbol. It means: call the expression (which is a parser) with the
current stream. If this sub-parser:</p>
<ul>
<li><p class="first">Returns an element, the pattern is bound to this result and the
next stream pattern component is tested.</p>
</li>
<li><p class="first">Raises the exception <code class="docutils literal"><span class="pre">Stream.Failure</span></code>, there are two cases:</p>
<ul class="simple">
<li>if the stream pattern component is the first one of the stream
case, the current parser also fails with the exception
<code class="docutils literal"><span class="pre">Stream.Failure</span></code>.</li>
<li>if the stream pattern component is not the first one of the
stream case, the current parser fails with the exception
<code class="docutils literal"><span class="pre">Stream.Error</span></code>.</li>
</ul>
<p>In this second case:</p>
<ul class="simple">
<li>If the stream pattern component is followed by a “question mark”
and an expression (which must be of type <code class="docutils literal"><span class="pre">string</span></code>),
the expression is evaluated and given as parameter of the
exception <code class="docutils literal"><span class="pre">Stream.Error</span></code>.</li>
<li>If the expression is followed by an “exclamation mark”, the test
and conversion from <code class="docutils literal"><span class="pre">Stream.Failure</span></code> to
<code class="docutils literal"><span class="pre">Stream.Error</span></code> is not done, and the parser just
raises <code class="docutils literal"><span class="pre">Stream.Failure</span></code> again. This is an
optimization which must be assumed by the programmer, in general
when he knows that the sub-parser called never raises
<code class="docutils literal"><span class="pre">Stream.Failure</span></code> (for example if the called parser
ends with a parser case containing an empty stream pattern). See
“no error optionization” below.</li>
<li>Otherwise the exception parameter is the empty string.</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">A pattern, which is bound to the current stream.</p>
</li>
</ul>
<p>Notice that patterns are bound immediately and can be used in the next
stream pattern component.</p>
</div>
<div class="section" id="let-statement">
<h4>Let statement<a class="headerlink" href="#let-statement" title="Permalink to this headline">¶</a></h4>
<p>Between stream pattern components, it is possible to use the <code class="docutils literal"><span class="pre">let..in</span></code>
construction. This is not considered as a real stream pattern
component, in the fact that is is not tested against the exception
<code class="docutils literal"><span class="pre">Stream.Failure</span></code> it may raise. It can be useful for
intermediate computation. In particular, it is used internally by the
lexers (see chapter about  <a class="reference internal" href="#lexers"><span class="std std-ref">Stream lexers</span></a> as character stream parsers).</p>
<p>Example of use, when an expression have to be used several times (in
the example, <code class="docutils literal"><span class="pre">d</span> <span class="pre">a</span></code>, which is bound to the variable
<code class="docutils literal"><span class="pre">c</span></code>)::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span>
  <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
     <span class="n">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">d</span> <span class="n">a</span> <span class="ow">in</span>
     <span class="n">e</span> <span class="o">=</span>
       <span class="n">parser</span>
       <span class="p">[</span> <span class="p">[:</span> <span class="n">f</span> <span class="o">=</span> <span class="n">g</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="n">c</span>
       <span class="o">|</span> <span class="p">[:</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="p">]</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">e</span>
</pre></div>
</div>
</div>
<div class="section" id="lookahead">
<h4>Lookahead<a class="headerlink" href="#lookahead" title="Permalink to this headline">¶</a></h4>
<p>The lookahead feature allows to look at several terminals in the
stream without removing them, in order to take decisions when more
than one terminal is necessary.</p>
<p>For example, when parsing the normal syntax of the OCaml language,
there is a problem, in recursing descendent parsing, for the cases
where to treat and differentiate the following inputs::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="o">-</span><span class="p">)</span>
</pre></div>
</div>
<p>The first case is treated in a rule, telling: “a left parenthesis,
followed by an expression, and a right parenthesis”. The second one is
“a left parenthesis, an operator, a right parenthesis”. Programming it
like this (left factorizing the first parenthesis)::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
  [: `Lparen;
     e =
       parser
       [ [: e = expr; `Rparen :] -&gt; e
       | [: `Minus; `Rparen :] -&gt; minus_op ] :] -&gt; e
</pre></div>
</div>
<p>does not work if the input is <code class="docutils literal"><span class="pre">(-)</span></code> because the rule <code class="docutils literal"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">expr</span></code>
accepts the minus sign as expression start, removing it from the input
stream and fails as parsing error, while encountering the right
parenthesis.</p>
<p>Conversely, writing it this way::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
  [: `Lparen;
     e =
       parser
       [ [: `Minus; `Rparen :] -&gt; minus_op
       | [: e = expr; `Rparen :] -&gt; e ] :] -&gt; e
</pre></div>
</div>
<p>does not help, because if the input is <code class="docutils literal"><span class="pre">(-x+1)</span></code> the rule
above starting with `` <cite>Minus`</cite> is accepted and the
exception <code class="docutils literal"><span class="pre">Stream.Error</span></code> is raised while encountering the
variable <code class="docutils literal"><span class="pre">x</span></code> since a right parenthesis is expected.</p>
<p>In general, this kind of situation is best resolved by a left
factorization of the parser cases (see the section “Semantics” above),
but that is not possible in this case. The solution is to test whether
the character after the minus sign is a right parenthesis::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
  [: `Lparen;
     e =
       parser
       [ [: ?= [ _ Rparen ]; `Minus; `Rparen :] -&gt; minus_op
       | [: e = expr; `Rparen :] -&gt; e ] :] -&gt; e
</pre></div>
</div>
<p>It is possible to put several lists of patterns separated by a
vertical bar in the lookahead construction, but with a limitation (due
to the implementation): all lists of patterns must have the same
number of elements.</p>
</div>
<div class="section" id="no-error-optimization">
<h4>No error optimization<a class="headerlink" href="#no-error-optimization" title="Permalink to this headline">¶</a></h4>
<p>The “no error optimization” is the fact to end a stream pattern
component of kind “non-terminal” (“pattern” “equal” “expression”) by
the character “exclamation mark”. Like said above, this inhibits the
transformation of the exception <code class="docutils literal"><span class="pre">Stream.Failure</span></code>,
possibly raised by the called parser, into the exception
<code class="docutils literal"><span class="pre">Stream.Error</span></code>.</p>
<p>The code::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser [: a = b; c = d ! :] -&gt; e
</pre></div>
</div>
<p>is equivalent to::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">s</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">d</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">e</span>
</pre></div>
</div>
<p>One interest of the first syntax is that it shows to readers that
<code class="docutils literal"><span class="pre">d</span></code> is indeed a syntactic sub-parser. In the second syntax, it is
called in the semantic action, which makes the parser case not so
clear, as far as readability is concerned.</p>
<p>If the stream pattern component is at end of the stream pattern, this
allow possible tail recursion by the OCaml compiler, in the following
case::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser [: a = b; c = d ! :] -&gt; c
</pre></div>
</div>
<p>since it is equivalent (with the fact that <code class="docutils literal"><span class="pre">c</span></code> is at the
same time the pattern of the last case and the expression of the
parser case semantic action) to::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">s</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">d</span> <span class="n">s</span>
</pre></div>
</div>
<p>The call to <code class="docutils literal"><span class="pre">d</span> <span class="pre">s</span></code> can be a tail recursive call. Without the use of
the “exclamation mark” in the rule, the equivalent code is::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">s</span> <span class="p">:]</span> <span class="o">-&gt;</span>
  <span class="k">try</span> <span class="n">d</span> <span class="n">s</span> <span class="k">with</span> <span class="p">[</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">Error</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="p">]</span>
</pre></div>
</div>
<p>which is not tail recursive (due to the <code class="docutils literal"><span class="pre">try..with</span></code> construction
pushes a context), preventing the compiler to optimize its code. This
can be important when many recursive calls happen, since it can
overflow the OCaml stack.</p>
</div>
<div class="section" id="position">
<h4>Position<a class="headerlink" href="#position" title="Permalink to this headline">¶</a></h4>
<p>The optional “pattern” before and after a stream pattern is bound to
the current stream count. Indeed, streams internally contain a count
of their elements. At the beginning the count is zero. When an element
is removed, the count is incremented. The example::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="p">:]</span> <span class="n">ep</span> <span class="o">-&gt;</span> <span class="n">c</span>
</pre></div>
</div>
<p>is equivalent to::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">s</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">let</span> <span class="n">ep</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="n">count</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">c</span>
</pre></div>
</div>
<p>There is no direct syntax equivalent to the optional pattern at
beginning of the stream pattern::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="n">bp</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">c</span>
</pre></div>
</div>
<p>These optional patterns allow disposal of the stream count at the
beginning and at the end of the parser case, allowing to compute
locations of the rule in the source. In particular, if the stream is a
stream of characters, these counts are the source location in number
of characters.</p>
</div>
<div class="section" id="semantic-action">
<h4>Semantic action<a class="headerlink" href="#semantic-action" title="Permalink to this headline">¶</a></h4>
<p>In a parser case, after the stream pattern, there is an “arrow” and an
expression, called the “semantic action”. If the parser case is
matched the parser returns with the evaluated expression whose
environment contains all values bound in the stream pattern.</p>
</div>
</div>
<div class="section" id="remarks">
<h3>Remarks<a class="headerlink" href="#remarks" title="Permalink to this headline">¶</a></h3>
<div class="section" id="simplicity-vs-associativity">
<h4>Simplicity vs Associativity<a class="headerlink" href="#simplicity-vs-associativity" title="Permalink to this headline">¶</a></h4>
<p>This parsing technology has the advantage of simplicity of use and
understanding, but it does not treat the associativity of
operators. For example, if you write a parser like this (to compute
arithmetic expressions)::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>value rec expr =
  parser
  [ [: e1 = expr; `&#39;+&#39;; e2 = expr :] -&gt; e1 + e2
  | [: `(&#39;0&#39;..&#39;9&#39; as c) :] -&gt; Char.code c - Char.code &#39;0&#39; ]
</pre></div>
</div>
<p>this would loop endlessly, exactly as if you wrote code starting with::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">rec</span> <span class="n">expr</span> <span class="n">e</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">expr</span> <span class="n">e</span> <span class="ow">in</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>One solution is to treat the associativity “by hand”: by reading a
sub-expression, then looping with a parser which parses the operator
and another sub-expression, and so on.</p>
<p>An alternative solution is to write parsing “combinators”. Indeed,
parsers being normal functions, it is possible to make a function
which takes a parser as parameter and returning a parser using it. For
example, left and right associativity parsing combinators::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">rec</span> <span class="n">left_assoc</span> <span class="n">op</span> <span class="n">elem</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">rec</span> <span class="n">op_elem</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">parser</span>
    <span class="p">[</span> <span class="p">[:</span> <span class="n">t</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">op_elem</span> <span class="p">(</span><span class="n">t</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">r</span>
    <span class="o">|</span> <span class="p">[:</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="p">]</span>
  <span class="ow">in</span>
  <span class="n">parser</span> <span class="p">[:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">op_elem</span> <span class="n">x</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">r</span>
<span class="p">;</span>

<span class="n">value</span> <span class="n">rec</span> <span class="n">right_assoc</span> <span class="n">op</span> <span class="n">elem</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">rec</span> <span class="n">op_elem</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">parser</span>
    <span class="p">[</span> <span class="p">[:</span> <span class="n">t</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">op_elem</span> <span class="n">y</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="n">x</span> <span class="n">r</span>
    <span class="o">|</span> <span class="p">[:</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="p">]</span>
  <span class="ow">in</span>
  <span class="n">parser</span> <span class="p">[:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">op_elem</span> <span class="n">x</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">r</span>
<span class="p">;</span>
</pre></div>
</div>
<p>which can be used, e.g. like this::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>value expr =
  List.fold_right (fun op elem -&gt; op elem)
    [left_assoc (parser [: `&#39;+&#39; :] -&gt; fun x y -&gt; x +. y);
     left_assoc (parser [: `&#39;*&#39; :] -&gt; fun x y -&gt; x *. y);
     right_assoc (parser [: `&#39;^&#39; :] -&gt; fun x y -&gt; x ** y)]
    (parser [: `(&#39;0&#39;..&#39;9&#39; as c) :] -&gt; float (Char.code c - Char.code &#39;0&#39;))
;
</pre></div>
</div>
<p>and tested, e.g. in the toplevel, like that::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">of_string</span> <span class="s2">&quot;2^3^2+1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The same way, it is possible to parse non-context free grammars, by
programming parsers returning other parsers.</p>
<p>A third solution, to resolve the problem of associativity, is to use
the grammars of Camlp5, which have the other advantage that they are
extensible.</p>
</div>
<div class="section" id="lexing-vs-parsing">
<h4>Lexing vs Parsing<a class="headerlink" href="#lexing-vs-parsing" title="Permalink to this headline">¶</a></h4>
<p>In general, while analyzing a language, there are two levels:</p>
<ul class="simple">
<li>The level where the input, considered as a stream of characters, is
read to make a stream of tokens (for example “words”, if it is a
human language, or punctuation). This level is generally called
“lexing”.</li>
<li>The level where the input is a stream of tokens where grammar rules
are parsed. This level is generally called “parsing”.</li>
</ul>
<p>The “parser” construction described here can be used for both, thanks
to the polymorphism of OCaml:</p>
<ul class="simple">
<li>The lexing level is a “parser” of streams of characters returning
tokens.</li>
<li>The parsing level is a “parser” of streams of tokens returning
syntax trees.</li>
</ul>
<p>By comparison, the programs “lex” and “yacc” use two different
technologies. With “parser”s, it is possible to use the same one for
both.</p>
</div>
<div class="section" id="lexer-syntax-vs-parser-syntax">
<h4>Lexer syntax vs Parser syntax<a class="headerlink" href="#lexer-syntax-vs-parser-syntax" title="Permalink to this headline">¶</a></h4>
<p>For “lexers”, i.e. for the specific case of parsers when the input is
a stream of characters, it is possible to use a shorter syntax. See
the chapter on  <a class="reference internal" href="#lexers"><span class="std std-ref">Stream lexers</span></a>. They have another
syntax, shorter and adapted for the specific type
<code class="docutils literal"><span class="pre">char</span></code>. But they still are internally parsers of streams
with the same semantics.</p>
</div>
<div class="section" id="purely-functional-parsers">
<h4>Purely functional parsers<a class="headerlink" href="#purely-functional-parsers" title="Permalink to this headline">¶</a></h4>
<p>This system of parsers is imperative: while parsing, the stream
advances and the already parsed terminals disappear from the stream
structure. This is useful because it is not necessary to return the
remaining stream together with the normal result. This is the reason
there is this <code class="docutils literal"><span class="pre">Stream.Error</span></code> exception: when it is raised, it
means that some terminals have been consumed from the stream, which
are definitively lost, and therefore that are no more possible parser
cases to try.</p>
<p>An alternative is to use <a class="reference internal" href="#fparsers"><span class="std std-ref">Functional parsers</span></a> which use a new
stream type, lazy but not destructive. Their advantage is that they
use a limited backtrack: the case of <code class="docutils literal"><span class="pre">if..then..else..</span></code> and the
shorter <code class="docutils literal"><span class="pre">if..then..</span></code> work without having to left factorize the parser
cases, and there is no need to lookahead. They have no equivalent to
the exception <code class="docutils literal"><span class="pre">Stream.Error</span></code>: when all cases are tested,
and have failed, the parsers return the value <code class="docutils literal"><span class="pre">None</span></code>. The
drawback is that, when a parsing error happens, it is not easily
possible to know the location of the error in the input, as the
initial stream has not been modified: the system would indicate a
failure at the first character of the first line: this is a general
drawback of backtracking parsers. See the solutions found to this
problem in the chapter about <a class="reference internal" href="#fparsers"><span class="std std-ref">Functional parsers</span></a>.</p>
<p>A second alternative is to use the <a class="reference internal" href="#bparsers"><span class="std std-ref">Backtracking parsers</span></a>. They
use the same stream type as the functional parsers, but they test more
cases than them. They have the same advantages and drawbacks than the
functional parsers.</p>
</div>
</div>
</div>
<div class="section" id="stream-lexers">
<span id="lexers"></span><h2>Stream lexers<a class="headerlink" href="#stream-lexers" title="Permalink to this headline">¶</a></h2>
<p>The file <code class="docutils literal"><span class="pre">pa_lexer.cmo</span></code> is a Camlp5 syntax extension kit for parsers
of streams of the type <code class="docutils literal"><span class="pre">char</span></code>. This syntax is shorter and more
readable than its equivalent version written with
<a class="reference internal" href="#parsers"><span class="std std-ref">Stream parsers</span></a>. Like classical parsers, they use recursive
descendant parsing. They are also pure syntax sugar, and each lexer
written with this syntax can be written using normal parsers syntax.</p>
<p>(An old version, named <code class="docutils literal"><span class="pre">pa_lex.cmo</span></code> was provided before with a
different syntax. It is no longer distributed, its proposed syntax
being confusing.)</p>
<div class="section" id="id1">
<h3>Introduction<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Classical parsers in OCaml apply to streams of any type of values. For
the specific type <code class="docutils literal"><span class="pre">char</span></code>, it has been possible to shorten the encoding
in several ways, in particular by using strings to group several
characters together, and by hiding the management of a “lexing
buffer”, a data structure recording the matched characters.</p>
<p>Let us take an example. The following function parses a left bracket
followed by a less, a colon or nothing, and record the result in a
buffer. In classical parsers syntax, this could be written like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>fun buf -&gt;
  parser
  [ [: `&#39;[&#39;; `&#39;&lt;&#39; :] -&gt;
      Plexing.Lexbuf.add &#39;&lt;&#39; (Plexing.Lexbuf.add &#39;[&#39; buf)
  | [: `&#39;[&#39;; `&#39;:&#39; :] -&gt;
      Plexing.Lexbuf.add &#39;:&#39; (Plexing.Lexbuf.add &#39;[&#39; buf)
  | [: `&#39;[&#39; :] -&gt;
      Plexing.Lexbuf &#39;[&#39; buf ]
</pre></div>
</div>
<p>With the new syntax, it is possible to write it as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">lexer</span> <span class="p">[</span> <span class="s2">&quot;[&lt;&quot;</span> <span class="o">|</span> <span class="s2">&quot;[:&quot;</span> <span class="o">|</span> <span class="s2">&quot;[&quot;</span> <span class="p">]</span>
</pre></div>
</div>
<p>The two codes are strictly equivalent, but the lexer version is easier
to write and understand, and is much shorter.</p>
</div>
<div class="section" id="id2">
<h3>Syntax<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>When loading the syntax extension <code class="docutils literal"><span class="pre">pa_lexer.cmo</span></code>, the OCaml syntax
is extended as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="n">expression</span> <span class="p">::</span><span class="o">=</span> <span class="n">lexer</span>
             <span class="n">lexer</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;lexer&quot;</span> <span class="s2">&quot;[&quot;</span> <span class="n">rules</span> <span class="s2">&quot;]&quot;</span>
             <span class="n">rules</span> <span class="p">::</span><span class="o">=</span> <span class="n">ne</span><span class="o">-</span><span class="n">rules</span> <span class="n">rule</span>
                     <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
          <span class="n">ne</span><span class="o">-</span><span class="n">rules</span> <span class="p">::</span><span class="o">=</span> <span class="n">ne</span><span class="o">-</span><span class="n">rules</span> <span class="s2">&quot;|&quot;</span> <span class="n">rule</span>
                     <span class="o">|</span> <span class="n">rule</span>
              <span class="n">rule</span> <span class="p">::</span><span class="o">=</span> <span class="n">symbols</span> <span class="p">[</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="n">action</span> <span class="p">]</span>
           <span class="n">symbols</span> <span class="p">::</span><span class="o">=</span> <span class="n">symbols</span> <span class="n">symbol</span> <span class="n">err</span>
                     <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
            <span class="n">symbol</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;_&quot;</span> <span class="n">no</span><span class="o">-</span><span class="n">record</span><span class="o">-</span><span class="n">opt</span>
                     <span class="o">|</span> <span class="n">CHAR</span> <span class="n">no</span><span class="o">-</span><span class="n">record</span><span class="o">-</span><span class="n">opt</span>
                     <span class="o">|</span> <span class="n">CHAR</span> <span class="s2">&quot;-&quot;</span> <span class="n">CHAR</span> <span class="n">no</span><span class="o">-</span><span class="n">record</span><span class="o">-</span><span class="n">opt</span>
                     <span class="o">|</span> <span class="n">STRING</span> <span class="n">no</span><span class="o">-</span><span class="n">record</span><span class="o">-</span><span class="n">opt</span>
                     <span class="o">|</span> <span class="n">simple</span><span class="o">-</span><span class="n">expression</span>
                     <span class="o">|</span> <span class="s2">&quot;?=&quot;</span> <span class="s2">&quot;[&quot;</span> <span class="n">lookaheads</span> <span class="s2">&quot;]&quot;</span>
                     <span class="o">|</span> <span class="s2">&quot;[&quot;</span> <span class="n">rules</span> <span class="s2">&quot;]&quot;</span>
     <span class="n">no</span><span class="o">-</span><span class="n">record</span><span class="o">-</span><span class="n">opt</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;/&quot;</span>
                     <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
 <span class="n">simple</span><span class="o">-</span><span class="n">expression</span> <span class="p">::</span><span class="o">=</span> <span class="n">LIDENT</span>
                     <span class="o">|</span> <span class="s2">&quot;(&quot;</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="s2">&quot;)&quot;</span>
        <span class="n">lookaheads</span> <span class="p">::</span><span class="o">=</span> <span class="n">lookaheads</span> <span class="s2">&quot;|&quot;</span> <span class="n">lookahead</span><span class="o">-</span><span class="n">sequence</span>
                     <span class="o">|</span> <span class="n">lookahead</span><span class="o">-</span><span class="n">sequence</span>
<span class="n">lookahead</span><span class="o">-</span><span class="n">sequence</span> <span class="p">::</span><span class="o">=</span> <span class="n">lookahead</span><span class="o">-</span><span class="n">symbols</span>
                     <span class="o">|</span> <span class="n">STRING</span>
 <span class="n">lookahead</span><span class="o">-</span><span class="n">symbols</span> <span class="p">::</span><span class="o">=</span> <span class="n">lookahead</span><span class="o">-</span><span class="n">symbols</span> <span class="n">lookahead</span><span class="o">-</span><span class="n">symbol</span>
                     <span class="o">|</span> <span class="n">lookahead</span><span class="o">-</span><span class="n">symbol</span>
  <span class="n">lookahead</span><span class="o">-</span><span class="n">symbol</span> <span class="p">::</span><span class="o">=</span> <span class="n">CHAR</span>
                     <span class="o">|</span> <span class="n">CHAR</span> <span class="s2">&quot;-&quot;</span> <span class="n">CHAR</span>
                     <span class="o">|</span> <span class="s2">&quot;_&quot;</span>
               <span class="n">err</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;?&quot;</span> <span class="n">simple</span><span class="o">-</span><span class="n">expression</span>
                     <span class="o">|</span> <span class="s2">&quot;!&quot;</span>
                     <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
            <span class="n">action</span> <span class="p">::</span><span class="o">=</span> <span class="n">expression</span>
</pre></div>
</div>
<p>The identifiers <code class="docutils literal"><span class="pre">STRING</span></code>, <code class="docutils literal"><span class="pre">CHAR</span></code> and <code class="docutils literal"><span class="pre">LIDENT</span></code> above represent
the OCaml tokens corresponding to string, character and lowercase
identifier (identifier starting with a lowercase character).</p>
<p>Moreover, together with that syntax extension, another extension is
added the entry <code class="docutils literal"><span class="pre">expression</span></code>, typically for the semantics
actions of the <code class="docutils literal"><span class="pre">lexer</span></code> statement above, but not only. It is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">expression</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;$&quot;</span> <span class="s2">&quot;add&quot;</span> <span class="n">STRING</span>
             <span class="o">|</span> <span class="s2">&quot;$&quot;</span> <span class="s2">&quot;buf&quot;</span>
             <span class="o">|</span> <span class="s2">&quot;$&quot;</span> <span class="s2">&quot;empty&quot;</span>
             <span class="o">|</span> <span class="s2">&quot;$&quot;</span> <span class="s2">&quot;pos&quot;</span>
</pre></div>
</div>
<p>Remark: the identifiers <code class="docutils literal"><span class="pre">add</span></code>, <code class="docutils literal"><span class="pre">buf</span></code>, <code class="docutils literal"><span class="pre">empty</span></code> and <code class="docutils literal"><span class="pre">pos</span></code> are
not keywords (they are not reserved words) but just identifiers. On
the contrary, the identifier <code class="docutils literal"><span class="pre">lexer</span></code>, which introduces the syntax,
is a new keyword and cannot be used as variable identifier any more.</p>
</div>
<div class="section" id="semantics">
<h3>Semantics<a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h3>
<p>A lexer defined in the syntax above is a shortcut version of a parser
applied to the specific case of streams of characters. It could be
written with a normal parser. The proposed syntax is much shorter,
easier to use and to understand, and silently takes care of the lexing
buffer for the programmer. The lexing buffers are data structures,
which are passed as parameters to called lexers and returned by them.</p>
<p>Our lexers are of the type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Plexing</span><span class="o">.</span><span class="n">Lexbuf</span><span class="o">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">Stream</span><span class="o">.</span><span class="n">t</span> <span class="n">char</span> <span class="o">-&gt;</span> <span class="n">u</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">u</span></code> is a type which depends on what the lexer returns. If
there is no semantic action (since it it optional), this type is
automatically <code class="docutils literal"><span class="pre">Plexing.Lexbuf.t</span></code> also.</p>
<p>A lexer is, actually, a function with two implicit parameters: the
first one is the lexing buffer itself, and the second one the
stream. When called, it tries to match the stream against its first
rule. If it fails, it tries its second rule, and so on, up to its last
rule. If the last rule fails, the lexer fails by raising the exception
<code class="docutils literal"><span class="pre">Stream.Failure</span></code>. All of this is the usual behaviour of
<a class="reference internal" href="#parsers"><span class="std std-ref">Stream parsers</span></a>.</p>
<p>In a rule, when a character is matched, it is inserted into the lexing
buffer, except if the “no record” feature is used (see further).</p>
<p>Rules which have no semantic action return the lexing buffer itself.</p>
<div class="section" id="symbols">
<h4>Symbols<a class="headerlink" href="#symbols" title="Permalink to this headline">¶</a></h4>
<p>The different kinds or symbols in a rule are:</p>
<ul class="simple">
<li>The token “underscore”, which represents any character. Fails only
if the stream is empty.</li>
<li>A character which represents a matching of this character.</li>
<li>A character followed by the minus sign and by another character
which represent all characters in the range between the two
characters in question.</li>
<li>A string with represents a matching of all its characters, one after
the other.</li>
<li>An expression corresponding to a call to another lexer, which takes
the buffer as first parameter and returns another lexing buffer with
all characters found in the stream added to the initial lexing
buffer.</li>
<li>The sequence <code class="docutils literal"><span class="pre">?=</span></code> introducing lookahead characters.</li>
<li>A rule, recursively, between brackets, inlining a lexer.</li>
</ul>
<p>In the cases matching characters (namely underscore, character,
characters range and string), the symbol can be optionally followed by
the “no record” character “slash” specifying that the found
character(s) are not added into the lexing buffer. By default, they
are. This feature is useful, for example, writing a lexer which parses
strings, when the initial double quote and final double quote should
not be part of the string itself.</p>
<p>Moreover, a symbol can be followed by an optional error indicator,
which can be:</p>
<ul class="simple">
<li>The character <code class="docutils literal"><span class="pre">?</span></code> (question mark) followed by a string expression,
telling that, if there is a syntax error at this point (i.e. the
symbol is not matched although the beginning of the rule was), the
exception <code class="docutils literal"><span class="pre">Stream.Error</span></code> is raised with that string as
parameter. Without this indicator, it is raised with the empty
string. This is the same behaviour than with classical
<a class="reference internal" href="#parsers"><span class="std std-ref">Stream parsers</span></a>.</li>
<li>The character <code class="docutils literal"><span class="pre">!</span></code> (exclamation mark), which is just an indicator
to let the syntax expander optimize the code. If the programmer is
sure that the symbol never fails (i.e. never raises
<code class="docutils literal"><span class="pre">Stream.Failure</span></code>), in particular if this symbol recognizes the
empty rule, he can add this exclamation mark. If it is used
correctly (the compiler cannot check it), the behaviour is identical
as without the <code class="docutils literal"><span class="pre">!</span></code>, except that the code is shorter and faster,
and can sometimes be tail recursive. If the indication is not
correct, the behaviour of the lexer is undefined.</li>
</ul>
</div>
<div class="section" id="specific-expressions">
<h4>Specific expressions<a class="headerlink" href="#specific-expressions" title="Permalink to this headline">¶</a></h4>
<p>When loading this syntax extension, the entry
<code class="docutils literal"><span class="pre">&lt;expression&gt;</span></code>, at level labelled <code class="docutils literal"><span class="pre">&quot;simple&quot;</span></code> of the OCaml
language is extended with the following rules:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">$add</span></code> followed by a string, specifing that the programmer wants
to add all characters of the string in the lexing buffer. It returns
the new lexing buffer. It corresponds to an iteration of calls to
<code class="docutils literal"><span class="pre">Plexing.Lexbuf.add</span></code> with all characters of the string with the
current lexing buffer as initial parameter.</li>
<li><code class="docutils literal"><span class="pre">$buf</span></code> which returns the lexing buffer converted into string.</li>
<li><code class="docutils literal"><span class="pre">$empty</span></code> which returns an empty lexing buffer.</li>
<li><code class="docutils literal"><span class="pre">$pos</span></code> which returns the current position of the stream in number
of characters (starting at zero).</li>
</ul>
</div>
<div class="section" id="id3">
<h4>Lookahead<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Lookahead is useful in some cases, when factorization of rules is
impossible. To understand how it is useful, a first remark must be
done, about the usual behaviour of Camlp5 stream parsers.</p>
<p>Stream parsers (including these lexers) use a limited parsing
algorithm, in a way that when the first symbol of a rule is matched,
all the following symbols of the same rule must apply, otherwise it is
a syntax error. There is no backtrack. In most of the cases, left
factorization of rules resolve conflicting problems. For example, in
parsers of tokens (which is not our case here, since we parse only
characters), when one writes a parser to recognize both typical
grammar rules <code class="docutils literal"><span class="pre">if..then..else</span></code> and the shorter <code class="docutils literal"><span class="pre">if..then..</span></code>, the
system transforms them into a single rule starting with <code class="docutils literal"><span class="pre">if..then..</span></code>
followed by a call to a parser recognizing <code class="docutils literal"><span class="pre">else..</span></code> <em>or</em> nothing.</p>
<p>Sometimes, however, this left factorization is not possible. A
lookahead of the stream to check the presence of some elements (these
elements being characters, if we are using this “lexer” syntax) might
be necessary to decide if is a good idea to start the rule. This
lookahead feature may unfreeze several characters from the input
stream but without removing them.</p>
<p>Syntactically, a lookahead starts with <code class="docutils literal"><span class="pre">?=</span></code> and is followed by
one or several lookahead sequences separated by the vertical bar
<code class="docutils literal"><span class="pre">|</span></code>, the whole list being enclosed by braces.</p>
<p>If there are several lookaheads, they must all be of the same size
(contain the same number of characters).</p>
<p>If the lookahead sequence is just a string, it corresponds to all
characters of this string in the order (which is different for strings
outside lookahead sequences, representing a choice of all characters).</p>
<p>Examples of lookaheads:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>?= [ _ &#39;&#39;&#39; | &#39;\\&#39; _ ]
?= [ &quot;&lt;&lt;&quot; | &quot;&lt;:&quot; ]
</pre></div>
</div>
<p>The first line above matches a stream whose second character is a
quote or a stream whose first character is a backslash (real example
in the lexer of OCaml, in the library of Camlp5, named
“plexer.ml”). The second line matches a stream starting with the two
characters <code class="docutils literal"><span class="pre">&lt;</span></code> and <code class="docutils literal"><span class="pre">&lt;</span></code> or starting with the two characters <code class="docutils literal"><span class="pre">&lt;</span></code>
and <code class="docutils literal"><span class="pre">:</span></code> (this is another example in the same file).</p>
</div>
<div class="section" id="semantic-actions-of-rules">
<h4>Semantic actions of rules<a class="headerlink" href="#semantic-actions-of-rules" title="Permalink to this headline">¶</a></h4>
<p>By default, the result of a “lexer” is the current lexing buffer,
which is of type <code class="docutils literal"><span class="pre">Plexing.Lexbuf.t</span></code>. But it is possible to return
other values, by adding <code class="docutils literal"><span class="pre">-&gt;</span></code> at end of rules followed by the
expression you want to return, as in usual pattern matching in OCaml.</p>
<p>An interesting result, for example, could be the string corresponding
to the characters of the lexing buffer. This can be obtained by
returning the value <code class="docutils literal"><span class="pre">$buf</span></code>.</p>
</div>
<div class="section" id="a-complete-example">
<h4>A complete example<a class="headerlink" href="#a-complete-example" title="Permalink to this headline">¶</a></h4>
<p>A complete example can be seen in the sources of Camlp5,
file <code class="docutils literal"><span class="pre">lib/plexer.ml</span></code>. This is the lexer of OCaml, either “normal”
or”revised” syntax.</p>
</div>
<div class="section" id="compiling">
<h4>Compiling<a class="headerlink" href="#compiling" title="Permalink to this headline">¶</a></h4>
<p>To compile a file containing lexers, just load <code class="docutils literal"><span class="pre">pa_lexer.cmo</span></code> using
one of the following methods:</p>
<ul class="simple">
<li>Either by adding <code class="docutils literal"><span class="pre">pa_lexer.cmo</span></code> among the Camlp5 options. See the
Camlp5 manual page or documentation.</li>
<li>Or by adding <code class="docutils literal"><span class="pre">#load</span> <span class="pre">&quot;pa_lexer.cmo&quot;;</span></code> anywhere in the file, before
the usages of this “lexer” syntax.</li>
</ul>
</div>
<div class="section" id="how-to-display-the-generated-code">
<h4>How to display the generated code<a class="headerlink" href="#how-to-display-the-generated-code" title="Permalink to this headline">¶</a></h4>
<p>You can see the generated code, for a file <code class="docutils literal"><span class="pre">bar.ml</span></code> containing
lexers, by typing in a command line:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">camlp5r</span> <span class="n">pa_lexer</span><span class="o">.</span><span class="n">cmo</span> <span class="n">pr_r</span><span class="o">.</span><span class="n">cmo</span> <span class="n">bar</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>To see the equivalent code with stream parsers, use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">camlp5r</span> <span class="n">pa_lexer</span><span class="o">.</span><span class="n">cmo</span> <span class="n">pr_r</span><span class="o">.</span><span class="n">cmo</span> <span class="n">pr_rp</span><span class="o">.</span><span class="n">cmo</span> <span class="n">bar</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="functional-parsers">
<span id="fparsers"></span><h2>Functional parsers<a class="headerlink" href="#functional-parsers" title="Permalink to this headline">¶</a></h2>
<p>Purely functional parsers are an alternative of <a class="reference internal" href="#parsers"><span class="std std-ref">Stream parsers</span></a>
where the used stream type is a lazy non-destructive type. These
streams are lazy values, as in classical stream parsers, but the
values are not removed as long as the parsing advances.</p>
<p>To make them work, the parsers of purely functional streams return,
not the simple values, but a value of type option :
<code class="docutils literal"><span class="pre">None</span></code> meaning “no match” (the equivalent of the
exception <code class="docutils literal"><span class="pre">Parse.Failure</span></code> of normal streams) and
<code class="docutils literal"><span class="pre">Some</span> <span class="pre">(r,</span> <span class="pre">s)</span></code> meaning “the result is r and the remaining
stream is s”.</p>
<div class="section" id="id4">
<h3>Syntax<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>The syntax of purely functional parsers, when loading
<code class="docutils literal"><span class="pre">pa_fstream.cmo</span></code>, is the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="n">expression</span> <span class="p">::</span><span class="o">=</span> <span class="n">fparser</span>
                     <span class="o">|</span> <span class="n">match</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">fparser</span>
           <span class="n">fparser</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;fparser&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;[&quot;</span> <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="s2">&quot;]&quot;</span>
                     <span class="o">|</span> <span class="s2">&quot;fparser&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="n">parser</span><span class="o">-</span><span class="n">case</span>
<span class="n">match</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">fparser</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;match&quot;</span> <span class="n">expression</span> <span class="s2">&quot;with&quot;</span> <span class="n">fparser</span>
      <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="p">::</span><span class="o">=</span> <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="n">parser</span><span class="o">-</span><span class="n">case</span>
                     <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
       <span class="n">parser</span><span class="o">-</span><span class="n">case</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;[:&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span> <span class="s2">&quot;:]&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="n">expression</span>
                     <span class="o">|</span> <span class="s2">&quot;[:&quot;</span> <span class="s2">&quot;:]&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="n">expression</span>
    <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span> <span class="p">::</span><span class="o">=</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span>
                     <span class="o">|</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="s2">&quot;;&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span>
  <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;`&quot;</span> <span class="n">pattern</span>
                     <span class="o">|</span> <span class="s2">&quot;`&quot;</span> <span class="n">pattern</span> <span class="s2">&quot;when&quot;</span> <span class="n">expression</span>
                     <span class="o">|</span> <span class="n">pattern</span> <span class="s2">&quot;=&quot;</span> <span class="n">expression</span>
                     <span class="o">|</span> <span class="n">pattern</span>
                     <span class="o">|</span> <span class="s2">&quot;when&quot;</span> <span class="n">expression</span>
           <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="p">::</span><span class="o">=</span> <span class="n">pattern</span>
                     <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Notice that, unlike classical parsers, there is no difference, in a
stream pattern, between the first stream pattern component and the
other ones. In particular, there is no “question mark” syntax and
expression optionnally ending those components. Moreover, the
“lookahead” case is not necessary, we see further why. The syntaxes
“pattern when” and “let..in” inside stream patterns we see in
classical parsers are not implemented.</p>
</div>
<div class="section" id="id5">
<h3>Streams<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>The functional parsers are functions taking as parameters functional
streams, which are values of type <code class="docutils literal"><span class="pre">Fstream.t</span> <span class="pre">a</span></code> for some type
<code class="docutils literal"><span class="pre">a</span></code>. It is possible to build functional streams using the functions
defined in the module <code class="docutils literal"><span class="pre">Fstream</span></code>:</p>
<div class="section" id="fstream-from">
<h4>Fstream.from<a class="headerlink" href="#fstream-from" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">Fstream.from</span> <span class="pre">f</span></code> returns a stream built from the function <code class="docutils literal"><span class="pre">f</span></code>. To
create a new stream element, the function <code class="docutils literal"><span class="pre">f</span></code> is called with the
current stream count, starting with zero. The user function <code class="docutils literal"><span class="pre">f</span></code> must
return either <code class="docutils literal"><span class="pre">Some</span> <span class="pre">&lt;value&gt;</span></code> for a value or <code class="docutils literal"><span class="pre">None</span></code> to specify the
end of the stream.</p>
</div>
<div class="section" id="fstream-of-list">
<h4>Fstream.of_list<a class="headerlink" href="#fstream-of-list" title="Permalink to this headline">¶</a></h4>
<p>Return a stream built from the list in the same order.</p>
</div>
<div class="section" id="fstream-of-string">
<h4>Fstream.of_string<a class="headerlink" href="#fstream-of-string" title="Permalink to this headline">¶</a></h4>
<p>Return a stream of the characters of the string parameter.</p>
</div>
<div class="section" id="fstream-of-channel">
<h4>Fstream.of_channel<a class="headerlink" href="#fstream-of-channel" title="Permalink to this headline">¶</a></h4>
<p>Return a stream of the characters read from the input channel
parameter.</p>
</div>
</div>
<div class="section" id="id6">
<h3>Semantics of parsers<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<div class="section" id="fparser">
<h4>Fparser<a class="headerlink" href="#fparser" title="Permalink to this headline">¶</a></h4>
<p>The purely functional parsers act like classical parsers, with a
recursive descent algorithm, except that:</p>
<ul class="simple">
<li>If the first stream pattern component matches the beginning of the
stream, there is no error if the following stream patterns
components do not match: the control simply passes to the next
parser case with the initial stream.</li>
<li>If the semantic actions are of type <code class="docutils literal"><span class="pre">t</span></code>, the result of the parser
is of type <code class="docutils literal"><span class="pre">option</span> <span class="pre">(t</span> <span class="pre">*</span> <span class="pre">Fstream.t)</span></code>, not just <code class="docutils literal"><span class="pre">t</span></code> like in
classical parsers. If a stream pattern matches, the semantic action
is evaluated, giving some result <code class="docutils literal"><span class="pre">e</span></code> and the result of the parser
is <code class="docutils literal"><span class="pre">Some</span> <span class="pre">(e,</span> <span class="pre">strm)</span></code> where <code class="docutils literal"><span class="pre">strm</span></code> is the remaining stream.</li>
<li>If no parser case matches, the result of the parser is <code class="docutils literal"><span class="pre">None</span></code>.</li>
</ul>
</div>
<div class="section" id="error-position">
<h4>Error position<a class="headerlink" href="#error-position" title="Permalink to this headline">¶</a></h4>
<p>A difficulty, with purely functional parsers, is how to find the
position of the syntax error, when the input is wrong. Since the
system tries all parsers cases before returning <code class="docutils literal"><span class="pre">None</span></code>, and that the
initial stream is not affected, it is not possible to directly find
where the error happened. This is a problem for parsing using
backtracking (here, it is limited backtracking, but the problem is the
same).</p>
<p>The solution is to use the function <code class="docutils literal"><span class="pre">Fstream.count_unfrozen</span></code>
applied to the initial stream. Like its name says, it returns the
number of unfrozen elements of the stream, which is exactly the
longest match found. If the input is a stream of characters, the
return of this function is exactly the position in number of
characters from the beginning of the stream.</p>
<p>However, it is not possible to know directly which rule failed and
therefore it is not possible, as in classical parsers, to specify and
get clear error messages. Future versions of purely functional parsers
may propose solutions to resolve this problem.</p>
<p>Notice that, if using the <code class="docutils literal"><span class="pre">count_unfrozen</span></code> method, it is not
possible to reuse that same stream to call another parser, and hope to
get the right position of the error, if another error happens, since
it may test less terminals than the first parser. Use a fresh stream
in this case, if possible.</p>
</div>
</div>
</div>
<div class="section" id="backtracking-parsers">
<span id="bparsers"></span><h2>Backtracking parsers<a class="headerlink" href="#backtracking-parsers" title="Permalink to this headline">¶</a></h2>
<p>Backtracking parsers are a second alternative of
<a class="reference internal" href="#parsers"><span class="std std-ref">Stream parsers</span></a> and <a class="reference internal" href="#fparsers"><span class="std std-ref">Functional parsers</span></a>.</p>
<p>Backtracking parsers are close to functional parsers: they use the
same stream type, <code class="docutils literal"><span class="pre">Fstream.t</span></code>, and their syntax is almost
identical, its introducing keyword being <code class="docutils literal"><span class="pre">bparser</span></code> instead of
<code class="docutils literal"><span class="pre">fparser</span></code>.</p>
<p>The difference is that they are implemented with <em>full
backtracking</em> and that they return values of the type <code class="docutils literal"><span class="pre">option</span></code>
of the triplet: 1/ value, 2/ remaining stream and 3/ continuation.</p>
<div class="section" id="id7">
<h3>Syntax<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>The syntax of backtracking parsers is added together with the syntax
of functional parsers, when the kit <code class="docutils literal"><span class="pre">pa_fstream.cmo</span></code> is loaded. It is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="n">expression</span> <span class="p">::</span><span class="o">=</span> <span class="n">bparser</span>
                     <span class="o">|</span> <span class="n">match</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">bparser</span>
           <span class="n">bparser</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;bparser&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;[&quot;</span> <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="s2">&quot;]&quot;</span>
                     <span class="o">|</span> <span class="s2">&quot;bparser&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="n">parser</span><span class="o">-</span><span class="n">case</span>
<span class="n">match</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">bparser</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;match&quot;</span> <span class="n">expression</span> <span class="s2">&quot;with&quot;</span> <span class="n">bparser</span>
      <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="p">::</span><span class="o">=</span> <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="n">parser</span><span class="o">-</span><span class="n">case</span>
                     <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
       <span class="n">parser</span><span class="o">-</span><span class="n">case</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;[:&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span> <span class="s2">&quot;:]&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="n">expression</span>
                     <span class="o">|</span> <span class="s2">&quot;[:&quot;</span> <span class="s2">&quot;:]&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="n">expression</span>
    <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span> <span class="p">::</span><span class="o">=</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span>
                     <span class="o">|</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="s2">&quot;;&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span>
  <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;`&quot;</span> <span class="n">pattern</span>
                     <span class="o">|</span> <span class="s2">&quot;`&quot;</span> <span class="n">pattern</span> <span class="s2">&quot;when&quot;</span> <span class="n">expression</span>
                     <span class="o">|</span> <span class="n">pattern</span> <span class="s2">&quot;=&quot;</span> <span class="n">expression</span>
                     <span class="o">|</span> <span class="n">pattern</span>
                     <span class="o">|</span> <span class="s2">&quot;when&quot;</span> <span class="n">expression</span>
           <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="p">::</span><span class="o">=</span> <span class="n">pattern</span>
                     <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>Semantics<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<div class="section" id="algorithm">
<h4>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h4>
<p>The backtracking parsers, like classical parsers and functional
parsers, use a recursive descent algorithm. But:</p>
<ul class="simple">
<li>If a stream pattern component does not match the current position of
the input stream, the control is given to the next case of the
stream pattern component before it. If it is the first stream
pattern component, the rule (the stream pattern) is left and the
next rule is tested.</li>
</ul>
<p>For example, the following grammar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">-&gt;</span> <span class="n">X</span> <span class="n">Y</span>
<span class="n">X</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span>
<span class="n">Y</span> <span class="o">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>works, with the backtracking algorithm, for the input <code class="docutils literal"><span class="pre">a</span>&#160; <span class="pre">b</span></code>.</p>
<p>Parsing with the non-terminal <code class="docutils literal"><span class="pre">E</span></code>, the non-terminal <code class="docutils literal"><span class="pre">X</span></code> first
accepts the input <code class="docutils literal"><span class="pre">a</span> <span class="pre">b</span></code> with its first rule. Then when <code class="docutils literal"><span class="pre">Y</span></code> is
called, the parsing fails since nothing remains in the input stream.</p>
<p>In the rule <code class="docutils literal"><span class="pre">X</span> <span class="pre">Y</span></code> of the non-terminal <code class="docutils literal"><span class="pre">E</span></code>, the non-terminal <code class="docutils literal"><span class="pre">Y</span></code>
having failed, the control is given the the continuation of the
non-terminal <code class="docutils literal"><span class="pre">X</span></code>. This continuation is its second rule containing
only <code class="docutils literal"><span class="pre">a</span></code>. Then <code class="docutils literal"><span class="pre">Y</span></code> is called and accepted.</p>
<p>This case does not work with functional parsers since when the rule
<code class="docutils literal"><span class="pre">a</span> <span class="pre">b</span></code> of the non-terminal <code class="docutils literal"><span class="pre">X</span></code> is accepted, it is definitive. If
the input starts with <code class="docutils literal"><span class="pre">a</span> <span class="pre">b</span></code>, there is no way to apply its second
rule.</p>
<p>Backtracking parsers are strictly more powerful than functional
parsers.</p>
</div>
<div class="section" id="type">
<h4>Type<a class="headerlink" href="#type" title="Permalink to this headline">¶</a></h4>
<p>A backtracking parser whose stream elements are of type <code class="docutils literal"><span class="pre">t1</span></code>, and
whose semantic actions are of some type <code class="docutils literal"><span class="pre">t2</span></code>, is of type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Fstream</span><span class="o">.</span><span class="n">t</span> <span class="n">t1</span> <span class="o">-&gt;</span> <span class="n">option</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">Fstream</span><span class="o">.</span><span class="n">t</span> <span class="n">t1</span> <span class="o">*</span> <span class="n">Fstream</span><span class="o">.</span><span class="n">kont</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span>
</pre></div>
</div>
<p>If the backtracking parsers fails, its returning value is <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>If it succeeds, its returning value is <code class="docutils literal"><span class="pre">Some</span> <span class="pre">(x,</span> <span class="pre">strm,</span> <span class="pre">k)</span></code> where
<code class="docutils literal"><span class="pre">x</span></code> is its result, <code class="docutils literal"><span class="pre">strm</span></code> the remaining stream, and <code class="docutils literal"><span class="pre">k</span></code> the
continuation.</p>
<p>The continuation is internally used in the backtracking algorithm, but
is can also be used in the main call to compute the next solution,
using the function <code class="docutils literal"><span class="pre">Fstream.bcontinue</span></code>.</p>
<p>It is also possible to directly get the list of all solutions by
calling the function <code class="docutils literal"><span class="pre">Fstream.bparse_all</span></code>.</p>
</div>
<div class="section" id="syntax-errors">
<h4>Syntax errors<a class="headerlink" href="#syntax-errors" title="Permalink to this headline">¶</a></h4>
<p>Like for <a class="reference internal" href="#fparsers"><span class="std std-ref">Functional parsers</span></a>, in case of syntax error, the error
position can be found by using the function
<code class="docutils literal"><span class="pre">Fstream.count_unfrozen</span></code>, the token in error being the last unfrozen
element of the stream.</p>
<p>A syntax error is not really an error: for the backtracking parsers,
like for functional parsers, it is viewed as a “non-working” case and
another solution is searched.</p>
<p>In the backtracking algorithm, depending on the grammar and the input,
the search of the next solution can be very long. A solution is
proposed for that in the <a class="reference internal" href="#grammars"><span class="std std-ref">Extensible grammars</span></a> system when the parsing
algorithm is set to “backtracking”.</p>
</div>
</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>Here is an example which just shows the backtracking algorithm but
without parsing, an empty stream being given as parameter and never
referred.</p>
<p>It creates a list of three strings, each of them being chosen between
<code class="docutils literal"><span class="pre">&quot;A&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;B&quot;</span></code> and <code class="docutils literal"><span class="pre">&quot;C&quot;</span></code>.</p>
<p>The code is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#load &quot;pa_fstream.cmo&quot;;</span>
<span class="n">value</span> <span class="n">choice</span> <span class="o">=</span> <span class="n">bparser</span> <span class="p">[</span> <span class="p">[:</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="s2">&quot;A&quot;</span> <span class="o">|</span> <span class="p">[:</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="s2">&quot;B&quot;</span> <span class="o">|</span> <span class="p">[:</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="s2">&quot;C&quot;</span> <span class="p">];</span>
<span class="n">value</span> <span class="n">combine</span> <span class="o">=</span> <span class="n">bparser</span> <span class="p">[:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">choice</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">choice</span><span class="p">;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">choice</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">;</span> <span class="n">y</span><span class="p">;</span> <span class="n">z</span><span class="p">];</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">combine</span></code> returns the first solution:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># combine (fstream [: :]);</span>
<span class="o">-</span> <span class="p">:</span> <span class="n">option</span> <span class="p">(</span><span class="nb">list</span> <span class="n">string</span> <span class="o">*</span> <span class="n">Fstream</span><span class="o">.</span><span class="n">t</span> <span class="s1">&#39;_a * Fstream.kont &#39;</span><span class="n">_a</span> <span class="p">(</span><span class="nb">list</span> <span class="n">string</span><span class="p">))</span> <span class="o">=</span>
<span class="n">Some</span> <span class="p">([</span><span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">],</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Fstream</span><span class="o">.</span><span class="n">K</span> <span class="o">&lt;</span><span class="n">fun</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">Fstream.bparse_all</span></code> returns the list of all solutions,
showing the interest of the backtracking:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Fstream.bparse_all combine (fstream [: :]);</span>
<span class="o">-</span> <span class="p">:</span> <span class="nb">list</span> <span class="p">(</span><span class="nb">list</span> <span class="n">string</span><span class="p">)</span> <span class="o">=</span>
<span class="p">[[</span><span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">];</span>
 <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">];</span>
 <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">];</span>
 <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">];</span>
 <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">];</span>
 <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">];</span>
 <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;A&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;B&quot;</span><span class="p">];</span> <span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">;</span> <span class="s2">&quot;C&quot;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="extensible-grammars">
<span id="grammars"></span><h2>Extensible grammars<a class="headerlink" href="#extensible-grammars" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes the syntax and semantics of the extensible
grammars of Camlp5.</p>
<p>The extensible grammars are the most advanced parsing tool of
Camlp5. They apply to streams of characters using a lexer which has to
be previously defined by the programmer. In Camlp5, the syntax of the
OCaml language is defined with extensible grammars, which makes Camlp5
a bootstrapped system (it compiles its own features by itself).</p>
<div class="section" id="getting-started">
<h3>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h3>
<p>The extensible grammars are a system to build <em>grammar entries</em>
which can be extended dynamically. A grammar entry is an abstract
value internally containing a stream parser. The type of a grammar
entry is <code class="docutils literal"><span class="pre">Grammar.Entry.e</span> <span class="pre">t</span></code> where <code class="docutils literal"><span class="pre">t</span></code> is the type
of the values returned by the grammar entry.</p>
<p>To start with extensible grammars, it is necessary to build a
<em>grammar</em>, a value of type <code class="docutils literal"><span class="pre">Grammar.g</span></code>, using the function
<code class="docutils literal"><span class="pre">Grammar.gcreate</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">g</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">gcreate</span> <span class="n">lexer</span><span class="p">;</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">lexer</span></code> is a lexer previously defined. See the section
explaining the interface with lexers. In a first time, it is possible
to use a lexer of the module <code class="docutils literal"><span class="pre">Plexer</span></code> provided by Camlp5:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">g</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">gcreate</span> <span class="p">(</span><span class="n">Plexer</span><span class="o">.</span><span class="n">gmake</span> <span class="p">());</span>
</pre></div>
</div>
<p>Each grammar entry is associated with a grammar. Only grammar
entries of the same grammar can call each other. To create a grammar
entry, one has to use the function <code class="docutils literal"><span class="pre">Grammar.Entry.create</span></code> with
takes the grammar as first parameter and a name as second parameter. This
name is used in case of syntax errors. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">create</span> <span class="n">g</span> <span class="s2">&quot;expression&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>To apply a grammar entry, the function <code class="docutils literal"><span class="pre">Grammar.Entry.parse</span></code>
can be used. Its first parameter is the grammar entry, the second one
a stream of characters:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">parse</span> <span class="n">exp</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">of_string</span> <span class="s2">&quot;hello&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>But if you experiment this, since the entry was just created without
any rules, you receive an error message:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Stream</span><span class="o">.</span><span class="n">Error</span> <span class="s2">&quot;entry [expression] is empty&quot;</span>
</pre></div>
</div>
<p>To add grammar rules to the grammar entry, it is necessary to
<em>extend</em> it, using a specific syntactic statement:
<code class="docutils literal"><span class="pre">EXTEND</span></code>.</p>
</div>
<div class="section" id="syntax-of-the-extend-statement">
<h3>Syntax of the EXTEND statement<a class="headerlink" href="#syntax-of-the-extend-statement" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">EXTEND</span></code> statement is added in the expressions of the OCaml
language when the syntax extension kit <code class="docutils literal"><span class="pre">pa_extend.cmo</span></code> is
loaded. Its syntax is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">expression</span> <span class="p">::</span><span class="o">=</span> <span class="n">extend</span>
      <span class="n">extend</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;EXTEND&quot;</span> <span class="n">extend</span><span class="o">-</span><span class="n">body</span> <span class="s2">&quot;END&quot;</span>
 <span class="n">extend</span><span class="o">-</span><span class="n">body</span> <span class="p">::</span><span class="o">=</span> <span class="k">global</span><span class="o">-</span><span class="n">opt</span> <span class="n">entries</span>
  <span class="k">global</span><span class="o">-</span><span class="n">opt</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;GLOBAL&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="n">entry</span><span class="o">-</span><span class="n">names</span> <span class="s2">&quot;;&quot;</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
 <span class="n">entry</span><span class="o">-</span><span class="n">names</span> <span class="p">::</span><span class="o">=</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span> <span class="n">entry</span><span class="o">-</span><span class="n">names</span>
               <span class="o">|</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span>
       <span class="n">entry</span> <span class="p">::</span><span class="o">=</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span> <span class="s2">&quot;:&quot;</span> <span class="n">position</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;[&quot;</span> <span class="n">levels</span> <span class="s2">&quot;]&quot;</span>
<span class="n">position</span><span class="o">-</span><span class="n">opt</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;FIRST&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;LAST&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;BEFORE&quot;</span> <span class="n">label</span>
               <span class="o">|</span> <span class="s2">&quot;AFTER&quot;</span> <span class="n">label</span>
               <span class="o">|</span> <span class="s2">&quot;LIKE&quot;</span> <span class="n">string</span>
               <span class="o">|</span> <span class="s2">&quot;LEVEL&quot;</span> <span class="n">label</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
      <span class="n">levels</span> <span class="p">::</span><span class="o">=</span> <span class="n">level</span> <span class="s2">&quot;|&quot;</span> <span class="n">levels</span>
               <span class="o">|</span> <span class="n">level</span>
       <span class="n">level</span> <span class="p">::</span><span class="o">=</span> <span class="n">label</span><span class="o">-</span><span class="n">opt</span> <span class="n">assoc</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;[&quot;</span> <span class="n">rules</span> <span class="s2">&quot;]&quot;</span>
   <span class="n">label</span><span class="o">-</span><span class="n">opt</span> <span class="p">::</span><span class="o">=</span> <span class="n">label</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
   <span class="n">assoc</span><span class="o">-</span><span class="n">opt</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;LEFTA&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;RIGHTA&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;NONA&quot;</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
       <span class="n">rules</span> <span class="p">::</span><span class="o">=</span> <span class="n">rule</span> <span class="s2">&quot;|&quot;</span> <span class="n">rules</span>
               <span class="o">|</span> <span class="n">rule</span>
        <span class="n">rule</span> <span class="p">::</span><span class="o">=</span> <span class="n">psymbols</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="n">expression</span>
               <span class="o">|</span> <span class="n">psymbols</span><span class="o">-</span><span class="n">opt</span>
<span class="n">psymbols</span><span class="o">-</span><span class="n">opt</span> <span class="p">::</span><span class="o">=</span> <span class="n">psymbols</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
    <span class="n">psymbols</span> <span class="p">::</span><span class="o">=</span> <span class="n">psymbol</span> <span class="s2">&quot;;&quot;</span> <span class="n">psymbols</span>
               <span class="o">|</span> <span class="n">psymbol</span>
     <span class="n">psymbol</span> <span class="p">::</span><span class="o">=</span> <span class="n">symbol</span>
               <span class="o">|</span> <span class="n">pattern</span> <span class="s2">&quot;=&quot;</span> <span class="n">symbol</span>
      <span class="n">symbol</span> <span class="p">::</span><span class="o">=</span> <span class="n">keyword</span>
               <span class="o">|</span> <span class="n">token</span>
               <span class="o">|</span> <span class="n">token</span> <span class="n">string</span>
               <span class="o">|</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span>
               <span class="o">|</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span> <span class="s2">&quot;LEVEL&quot;</span> <span class="n">label</span>
               <span class="o">|</span> <span class="s2">&quot;SELF&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;NEXT&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;LIST0&quot;</span> <span class="n">symbol</span>
               <span class="o">|</span> <span class="s2">&quot;LIST0&quot;</span> <span class="n">symbol</span> <span class="s2">&quot;SEP&quot;</span> <span class="n">symbol</span> <span class="n">opt</span><span class="o">-</span><span class="n">opt</span><span class="o">-</span><span class="n">sep</span>
               <span class="o">|</span> <span class="s2">&quot;LIST1&quot;</span> <span class="n">symbol</span>
               <span class="o">|</span> <span class="s2">&quot;LIST1&quot;</span> <span class="n">symbol</span> <span class="s2">&quot;SEP&quot;</span> <span class="n">symbol</span> <span class="n">opt</span><span class="o">-</span><span class="n">opt</span><span class="o">-</span><span class="n">sep</span>
               <span class="o">|</span> <span class="s2">&quot;OPT&quot;</span> <span class="n">symbol</span>
               <span class="o">|</span> <span class="s2">&quot;FLAG&quot;</span> <span class="n">symbol</span>
               <span class="o">|</span> <span class="s2">&quot;V&quot;</span> <span class="n">symbol</span> <span class="n">opt</span><span class="o">-</span><span class="n">strings</span>
               <span class="o">|</span> <span class="s2">&quot;[&quot;</span> <span class="n">rules</span> <span class="s2">&quot;]&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;(&quot;</span> <span class="n">symbol</span> <span class="s2">&quot;)&quot;</span>
 <span class="n">opt</span><span class="o">-</span><span class="n">opt</span><span class="o">-</span><span class="n">sep</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;OPT_SEP&quot;</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
 <span class="n">opt</span><span class="o">-</span><span class="n">strings</span> <span class="p">::</span><span class="o">=</span> <span class="n">string</span> <span class="n">opt</span><span class="o">-</span><span class="n">strings</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
     <span class="n">keyword</span> <span class="p">::</span><span class="o">=</span> <span class="n">string</span>
       <span class="n">token</span> <span class="p">::</span><span class="o">=</span> <span class="n">uident</span>
       <span class="n">label</span> <span class="p">::</span><span class="o">=</span> <span class="n">string</span>
  <span class="n">entry</span><span class="o">-</span><span class="n">name</span> <span class="p">::</span><span class="o">=</span> <span class="n">qualid</span>
      <span class="n">qualid</span> <span class="p">::</span><span class="o">=</span> <span class="n">qualid</span> <span class="s2">&quot;.&quot;</span> <span class="n">qualid</span>
               <span class="o">|</span> <span class="n">uident</span>
               <span class="o">|</span> <span class="n">lident</span>
      <span class="n">uident</span> <span class="p">::</span><span class="o">=</span> <span class="s1">&#39;A&#39;</span><span class="o">-</span><span class="s1">&#39;Z&#39;</span> <span class="n">ident</span>
      <span class="n">lident</span> <span class="p">::</span><span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">-</span><span class="s1">&#39;z&#39;</span> <span class="o">|</span> <span class="s1">&#39;_&#39;</span> <span class="o">|</span> <span class="n">misc</span><span class="o">-</span><span class="n">letter</span><span class="p">)</span> <span class="n">ident</span>
       <span class="n">ident</span> <span class="p">::</span><span class="o">=</span> <span class="n">ident</span><span class="o">-</span><span class="n">char</span><span class="o">*</span>
  <span class="n">ident</span><span class="o">-</span><span class="n">char</span> <span class="p">::</span><span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">-</span><span class="s1">&#39;a&#39;</span> <span class="o">|</span> <span class="s1">&#39;A&#39;</span><span class="o">-</span><span class="s1">&#39;Z&#39;</span> <span class="o">|</span> <span class="s1">&#39;0&#39;</span><span class="o">-</span><span class="s1">&#39;9&#39;</span> <span class="o">|</span> <span class="s1">&#39;_&#39;</span> <span class="o">|</span> <span class="s1">&#39;&#39;&#39; | misc-letter)</span>
<span class="s1"> misc-letter ::= &#39;</span><span class="se">\12</span><span class="s1">8&#39;-&#39;</span><span class="se">\255</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>Other statements, <code class="docutils literal"><span class="pre">GEXTEND</span></code>, <code class="docutils literal"><span class="pre">DELETE_RULE</span></code>, <code class="docutils literal"><span class="pre">GDELETE_RULE</span></code> are
also defined by the same syntax extension kit. See further.</p>
<p>In the description above, only <code class="docutils literal"><span class="pre">EXTEND</span></code> and <code class="docutils literal"><span class="pre">END</span></code> are new keywords
(reserved words which cannot be used in variables, constructors or
module names). The other strings (e.g. <code class="docutils literal"><span class="pre">GLOBAL</span></code>, <code class="docutils literal"><span class="pre">LEVEL</span></code>,
<code class="docutils literal"><span class="pre">LIST0</span></code>, <code class="docutils literal"><span class="pre">LEFTA</span></code>, etc.) are not reserved.</p>
</div>
<div class="section" id="semantics-of-the-extend-statement">
<h3>Semantics of the EXTEND statement<a class="headerlink" href="#semantics-of-the-extend-statement" title="Permalink to this headline">¶</a></h3>
<p>The EXTEND statement starts with the <code class="docutils literal"><span class="pre">EXTEND</span></code> keyword and ends with
the <code class="docutils literal"><span class="pre">END</span></code> keyword.</p>
<div class="section" id="global-indicator">
<h4>GLOBAL indicator<a class="headerlink" href="#global-indicator" title="Permalink to this headline">¶</a></h4>
<p>After the first keyword, it is possible to see the identifier
<code class="docutils literal"><span class="pre">GLOBAL</span></code> followed by a colon, a list of entries names and a
semicolon. It says that these entries correspond to visible
(previously defined) entry variables, in the context of the EXTEND
statement, the other ones being locally and silently defined inside.</p>
<ul class="simple">
<li>If an entry, which is extended in the EXTEND statement, is in the
GLOBAL list, but is not defined in the context of the EXTEND
statement, the OCaml compiler will fail with the error “unbound
value”.</li>
<li>If there is no GLOBAL indicator, and an entry, which is extended in
the EXTEND statement, is not defined in the contex of the EXTEND
statement, the OCaml compiler will also fail with the error “unbound
value”.</li>
</ul>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">create</span> <span class="n">g</span> <span class="s2">&quot;exp&quot;</span><span class="p">;</span>
<span class="n">EXTEND</span>
  <span class="n">GLOBAL</span><span class="p">:</span> <span class="n">exp</span><span class="p">;</span>
  <span class="n">exp</span><span class="p">:</span> <span class="p">[</span> <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">bar</span> <span class="p">]</span> <span class="p">];</span>
  <span class="n">foo</span><span class="p">:</span> <span class="p">[</span> <span class="p">[</span> <span class="s2">&quot;foo&quot;</span> <span class="p">]</span> <span class="p">];</span>
  <span class="n">bar</span><span class="p">:</span> <span class="p">[</span> <span class="p">[</span> <span class="s2">&quot;bar&quot;</span> <span class="p">]</span> <span class="p">];</span>
<span class="n">END</span><span class="p">;</span>
</pre></div>
</div>
<p>The entry <code class="docutils literal"><span class="pre">exp</span></code> is an existing variable (defined by <code class="docutils literal"><span class="pre">value</span> <span class="pre">exp</span> <span class="pre">=</span> <span class="pre">...</span></code>).
On the other hand, the entries <code class="docutils literal"><span class="pre">foo</span></code> and <code class="docutils literal"><span class="pre">bar</span></code> have not been
defined. Because of the <code class="docutils literal"><span class="pre">GLOBAL</span></code> indicator, the system define them
locally.</p>
<p>Without the GLOBAL indicator, the three entries would have been
considered as global variables, therefore the OCaml compiler would
say “unbound variable” under the first undefined entry, <code class="docutils literal"><span class="pre">foo</span></code>.</p>
</div>
<div class="section" id="entries-list">
<h4>Entries list<a class="headerlink" href="#entries-list" title="Permalink to this headline">¶</a></h4>
<p>Then the list of entries extensions follow. An entry extension
starts with the entry name followed by a colon. An entry may have
several levels corresponding to several stream parsers which call the
ones the others (see further).</p>
<div class="section" id="optional-position">
<h5>Optional position<a class="headerlink" href="#optional-position" title="Permalink to this headline">¶</a></h5>
<p>After the colon, it is possible to specify a where to insert the defined levels:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>The identifier <code class="docutils literal"><span class="pre">FIRST</span></code> (resp. <code class="docutils literal"><span class="pre">LAST</span></code>) indicates that the level</dt>
<dd>must be inserted before (resp. after) all possibly existing levels
of the entry. They become their first (resp. last) levels.- The
identifier <code class="docutils literal"><span class="pre">BEFORE</span></code> (resp. <code class="docutils literal"><span class="pre">AFTER</span></code>) followed by a level label
(a string) indicates that the levels must be inserted before
(resp. after) that level, if it exists. If it does not exist, the
extend statement fails at run time.</dd>
</dl>
</li>
<li>The identifier <code class="docutils literal"><span class="pre">LIKE</span></code> followed by a string indicates that the
first level defined in the extend statement must be inserted in the
first already existing level with a rule containing this string as
keyword or token name. For example, <code class="docutils literal"><span class="pre">LIKE</span> <span class="pre">&quot;match&quot;</span></code> is the first
level having <code class="docutils literal"><span class="pre">match</span></code> as keyword. If there is no level with this
string, the extend statement fails at run time.</li>
<li>The identifier <code class="docutils literal"><span class="pre">LEVEL</span></code> followed by a level label indicates that
the first level defined in the extend statement must be inserted at
the given level, extending and modifying it. The other levels
defined in the statement are inserted after this level, and before
the possible levels following this level. If there is no level with
this label, the extend statement fails at run time.</li>
<li>By default, if the entry has no level, the levels defined in the
statement are inserted in the entry. Otherwise the first defined
level is inserted at the first level of the entry, extending or
modifying it. The other levels are inserted afterwards (before the
possible second level which may previously exist in the entry).</li>
</ul>
</div>
<div class="section" id="levels">
<h5>Levels<a class="headerlink" href="#levels" title="Permalink to this headline">¶</a></h5>
<p>After the optional <em>position</em>, the <em>level</em> list follow. The
levels are separated by vertical bars, the whole list being between
brackets.</p>
<p>A level starts with an optional label, which corresponds to its
name. This label is useful to specify this level in case of future
extensions, using the <em>position</em> (see previous section) or for
possible direct calls to this specific level.</p>
<p>The level continues with an optional associativity indicator, which
can be:</p>
<ul class="simple">
<li>LEFTA for left associativity (default),</li>
<li>RIGHTA for right associativity,</li>
<li>NONA for no associativity.</li>
</ul>
</div>
<div class="section" id="rules">
<h5>Rules<a class="headerlink" href="#rules" title="Permalink to this headline">¶</a></h5>
<p>At last, the grammar <em>rule</em> list appear. The rules are
separated by vertical bars, the whole list being brackets.</p>
<p>A rule looks like a match case in the <code class="docutils literal"><span class="pre">match</span></code> statement or a parser
case in the <code class="docutils literal"><span class="pre">parser</span></code> statement: a list of psymbols (see next
paragraph) separated by semicolons, followed by a right arrow and an
expression, the semantic action. Actually, the right arrow and
expression are optional: in this case, it is equivalent to an
expression which would be the unit <code class="docutils literal"><span class="pre">()</span></code> constructor.</p>
<p>A psymbol is either a pattern, followed with the equal sign and a
symbol, or by a symbol alone. It corresponds to a test of this symbol,
whose value is bound to the pattern if any.</p>
</div>
</div>
<div class="section" id="id9">
<h4>Symbols<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>A symbol is an item in a grammar rule. It is either:</p>
<ul class="simple">
<li>a keyword (a string): the input must match this keyword,</li>
<li>a token name (an identifier starting with an uppercase character),
optionally followed by a string: the input must match this token
(any value if no string, or that string if a string follows the
token name), the list of the available tokens depending on the
associated lexer (the list of tokens available with “Plexer.gmake
()” is: LIDENT, UIDENT, TILDEIDENT, TILDEIDENTCOLON, QUESTIONIDENT,
INT, INT_l, INT_L, INT_n, FLOAT, CHAR, STRING, QUOTATION, ANTIQUOT
and EOI; other lexers may propose other lists of tokens),</li>
<li>an entry name, which correspond to a call to this entry,</li>
<li>an entry name followed by the identifier <code class="docutils literal"><span class="pre">LEVEL</span></code> and a level
label, which correspond to the call to this entry at that level,-
the identifier <code class="docutils literal"><span class="pre">SELF</span></code> which is a recursive call to the present
entry, according to the associativity (i.e. it may be a call at the
current level, to the next level, or to the top level of the entry):
<code class="docutils literal"><span class="pre">SELF</span></code> is equivalent to the name of the entry itself,</li>
<li>the identifier <code class="docutils literal"><span class="pre">NEXT</span></code>, which is a call to the next level of the
current entry,</li>
<li>a left brace, followed by a list of rules separated by vertical
bars, and a right brace: equivalent to a call to an entry, with
these rules, inlined,</li>
<li>a meta symbol (see further),</li>
<li>a symbol between parentheses.</li>
</ul>
<p>The syntactic analysis follow the list of symbols. If it fails,
depending on the first items of the rule (see the section about the
kind of grammars recognized):</p>
<ul class="simple">
<li>the parsing may fail by raising the exception <code class="docutils literal"><span class="pre">Stream.Error</span></code></li>
<li>the parsing may continue with the next rule.</li>
</ul>
<div class="section" id="meta-symbols">
<h5>Meta symbols<a class="headerlink" href="#meta-symbols" title="Permalink to this headline">¶</a></h5>
<p>Extra symbols exist, allowing to manipulate lists or optional
symbols. They are:</p>
<ul class="simple">
<li>LIST0 followed by a symbol: this is a list of this symbol, possibly
empty,</li>
<li>LIST0 followed by a symbol, SEP and another symbol, and optional
OPT_SEP: this is a list, possibly empty, of the first symbol
separated by the second one, possibly ended with the separator if
OPT_SEP is present,</li>
<li>LIST1 followed by a symbol: this is a list of this symbol, with at
least one element,</li>
<li>LIST1 followed by a symbol, SEP and another symbol, and optional
OPT_SEP: this is a list, with at least one element, of the first
symbol separated by the second one, possibly ended with the
separator if OPT_SEP is present,</li>
<li>OPT followed by a symbol: equivalent to “this symbol or nothing”
returning a value of type <code class="docutils literal"><span class="pre">option</span></code>.</li>
<li>FLAG followed by a symbol: equivalent to “this symbol or nothing”,
returning a boolean.</li>
</ul>
<p>corresponds to either a call to the grammar entry <code class="docutils literal"><span class="pre">foo</span></code>, or to the
antiquotations <code class="docutils literal"><span class="pre">$bar:...$</span></code> or <code class="docutils literal"><span class="pre">$oops:...$</span></code>.</p>
</div>
<div class="section" id="id10">
<h5>Type<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>The type of the value returned by a V meta symbol is:</p>
<ul class="simple">
<li>in transitional mode, the type of its symbol parameter,</li>
<li>in strict mode, <code class="docutils literal"><span class="pre">Ploc.vala</span> <span class="pre">t</span></code>, where <code class="docutils literal"><span class="pre">t</span></code> is its symbol
parameter.</li>
</ul>
<p>In strict mode, if the symbol parameter is found, whose value is, say,
<code class="docutils literal"><span class="pre">x</span></code>, the result is <code class="docutils literal"><span class="pre">Ploc.VaVal</span> <span class="pre">x</span></code>. If an antiquotation is found
the result is <code class="docutils literal"><span class="pre">Ploc.VaAnt</span> <span class="pre">s</span></code> where <code class="docutils literal"><span class="pre">s</span></code> is some string containing
the antiquotation text and some other internal information.</p>
</div>
</div>
<div class="section" id="rules-insertion">
<h4>Rules insertion<a class="headerlink" href="#rules-insertion" title="Permalink to this headline">¶</a></h4>
<p>Remember that <code class="docutils literal"><span class="pre">EXTEND</span></code> is a statement, not a declaration:
the rules are added in the entries at run time. Each rule is
internally inserted in a tree, allowing the left factorization of the
rule. For example, with this list of rules (borrowed from the Camlp5
sources):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="s2">&quot;private&quot;</span><span class="p">;</span> <span class="s2">&quot;virtual&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">poly_type</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="s2">&quot;virtual&quot;</span><span class="p">;</span> <span class="s2">&quot;private&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">poly_type</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="s2">&quot;virtual&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">poly_type</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="s2">&quot;private&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">poly_type</span><span class="p">;</span> <span class="s2">&quot;=&quot;</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">expr</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="s2">&quot;private&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="n">sb</span> <span class="o">=</span> <span class="n">fun_binding</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">poly_type</span><span class="p">;</span> <span class="s2">&quot;=&quot;</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">expr</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="n">sb</span> <span class="o">=</span> <span class="n">fun_binding</span>
</pre></div>
</div>
<p>the rules are inserted in a tree and the result looks like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;method&quot;</span>
   <span class="o">|--</span> <span class="s2">&quot;private&quot;</span>
   <span class="o">|</span>       <span class="o">|--</span> <span class="s2">&quot;virtual&quot;</span>
   <span class="o">|</span>       <span class="o">|</span>       <span class="o">|--</span> <span class="n">label</span>
   <span class="o">|</span>       <span class="o">|</span>             <span class="o">|--</span> <span class="s2">&quot;:&quot;</span>
   <span class="o">|</span>       <span class="o">|</span>                  <span class="o">|--</span> <span class="n">poly_type</span>
   <span class="o">|</span>       <span class="o">|--</span> <span class="n">label</span>
   <span class="o">|</span>             <span class="o">|--</span> <span class="s2">&quot;:&quot;</span>
   <span class="o">|</span>             <span class="o">|</span>    <span class="o">|--</span> <span class="n">poly_type</span>
   <span class="o">|</span>             <span class="o">|</span>            <span class="o">|--</span> <span class="s2">&quot;:=&quot;</span>
   <span class="o">|</span>             <span class="o">|</span>                 <span class="o">|--</span> <span class="n">expr</span>
   <span class="o">|</span>             <span class="o">|--</span> <span class="n">fun_binding</span>
   <span class="o">|--</span> <span class="s2">&quot;virtual&quot;</span>
   <span class="o">|</span>       <span class="o">|--</span> <span class="s2">&quot;private&quot;</span>
   <span class="o">|</span>       <span class="o">|</span>       <span class="o">|--</span> <span class="n">label</span>
   <span class="o">|</span>       <span class="o">|</span>             <span class="o">|--</span> <span class="s2">&quot;:&quot;</span>
   <span class="o">|</span>       <span class="o">|</span>                  <span class="o">|--</span> <span class="n">poly_type</span>
   <span class="o">|</span>       <span class="o">|--</span> <span class="n">label</span>
   <span class="o">|</span>             <span class="o">|--</span> <span class="s2">&quot;:&quot;</span>
   <span class="o">|</span>                  <span class="o">|--</span> <span class="n">poly_type</span>
   <span class="o">|--</span> <span class="n">label</span>
         <span class="o">|--</span> <span class="s2">&quot;:&quot;</span>
         <span class="o">|</span>    <span class="o">|--</span> <span class="n">poly_type</span>
         <span class="o">|</span>            <span class="o">|--</span> <span class="s2">&quot;=&quot;</span>
         <span class="o">|</span>                 <span class="o">|--</span> <span class="n">expr</span>
         <span class="o">|--</span> <span class="n">fun_binding</span>
</pre></div>
</div>
<dl class="docutils">
<dt>This tree is built as long as rules are inserted. When used, by</dt>
<dd>applying the function <code class="docutils literal"><span class="pre">Grammar.Entry.parse</span></code> to the current
entry, the input is matched with that tree, starting from the tree
root, descending on it as long as the parsing advances.</dd>
</dl>
<p>There is a different tree by entry level.</p>
</div>
<div class="section" id="id11">
<h4>Semantic action<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>The semantic action, i.e. the expression following the right arrow in
rules, contains in its environment:</p>
<ul class="simple">
<li>the variables bound by the patterns of the symbols found in the
rules,</li>
<li>the specific variable <code class="docutils literal"><span class="pre">loc</span></code> which contain the location of the
whole rule in the source.</li>
</ul>
<p>The location is an abstract type defined in the module <code class="docutils literal"><span class="pre">Ploc</span></code> of
Camlp5.</p>
<p>It is possible to change the name of this variable by using the
option``-loc`` of Camlp5. For example, compiling a file like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">camlp5r</span> <span class="o">-</span><span class="n">loc</span> <span class="n">foobar</span> <span class="n">file</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>the variable name, for the location will be <code class="docutils literal"><span class="pre">foobar</span></code> instead of
<code class="docutils literal"><span class="pre">loc</span></code>.</p>
</div>
</div>
<div class="section" id="the-delete-rule-statement">
<h3>The DELETE_RULE statement<a class="headerlink" href="#the-delete-rule-statement" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">DELETE_RULE</span></code> statement is also added in the expressions of the
OCaml language when the syntax extension kit <code class="docutils literal"><span class="pre">pa_extend.cmo</span></code> is
loaded. Its syntax is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="n">expression</span> <span class="p">::</span><span class="o">=</span> <span class="n">delete</span><span class="o">-</span><span class="n">rule</span>
     <span class="n">delete</span><span class="o">-</span><span class="n">rule</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;DELETE_RULE&quot;</span> <span class="n">delete</span><span class="o">-</span><span class="n">rule</span><span class="o">-</span><span class="n">body</span> <span class="s2">&quot;END&quot;</span>
<span class="n">delete</span><span class="o">-</span><span class="n">rule</span><span class="o">-</span><span class="n">body</span> <span class="p">::</span><span class="o">=</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span> <span class="s2">&quot;:&quot;</span> <span class="n">symbols</span>
         <span class="n">symbols</span> <span class="p">::</span><span class="o">=</span> <span class="n">symbol</span> <span class="n">symbols</span>
                   <span class="o">|</span> <span class="n">symbol</span>
</pre></div>
</div>
<p>See the syntax of the EXTEND statement for the meaning of the syntax
entries not defined above.</p>
<p>The entry is scanned for a rule matching the giving symbol list. When
found, the rule is removed. If no rule is found, the exception
<code class="docutils literal"><span class="pre">Not_found</span></code> is raised.</p>
</div>
<div class="section" id="extensions-fold0-and-fold1">
<span id="grammars-extensions-fold0-and-fold1"></span><h3>Extensions FOLD0 and FOLD1<a class="headerlink" href="#extensions-fold0-and-fold1" title="Permalink to this headline">¶</a></h3>
<p>When loading <code class="docutils literal"><span class="pre">pa_extfold.cmo</span></code> after <code class="docutils literal"><span class="pre">pa_extend.cmo</span></code>, the entry
<code class="docutils literal"><span class="pre">symbol</span></code> of the EXTEND statement is extended with what is named the
&lt;em&gt;fold iterators&lt;/em&gt;, like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>     <span class="n">symbol</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;FOLD0&quot;</span> <span class="n">simple_expr</span> <span class="n">simple_expr</span> <span class="n">symbol</span>
              <span class="o">|</span> <span class="s2">&quot;FOLD1&quot;</span> <span class="n">simple_expr</span> <span class="n">simple_expr</span> <span class="n">symbol</span>
              <span class="o">|</span> <span class="s2">&quot;FOLD0&quot;</span> <span class="n">simple_expr</span> <span class="n">simple_expr</span> <span class="n">symbol</span> <span class="s2">&quot;SEP&quot;</span> <span class="n">symbol</span>
              <span class="o">|</span> <span class="s2">&quot;FOLD1&quot;</span> <span class="n">simple_expr</span> <span class="n">simple_expr</span> <span class="n">symbol</span> <span class="s2">&quot;SEP&quot;</span> <span class="n">symbol</span>
<span class="n">simple_expr</span> <span class="p">::</span><span class="o">=</span> <span class="n">expr</span> <span class="p">(</span><span class="n">level</span> <span class="s2">&quot;simple&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Like their equivalent with the lists iterators: <code class="docutils literal"><span class="pre">LIST0</span></code>, <code class="docutils literal"><span class="pre">LIST1</span></code>,
<code class="docutils literal"><span class="pre">LIST0SEP</span></code>, <code class="docutils literal"><span class="pre">LIST1SEP</span></code>, they read a sequence of symbols, possibly
with the separators, but instead of building the list of these
symbols, apply a fold function to each symbol, starting at the second
“expr” (which must be a expression node) and continuing with the first
“expr” (which must be a function taking two expressions and returing a
new expression).</p>
<p>The list iterators can be seen almost as a specific case of these fold
iterators where the initial “expr” would be:</p>
<dl class="docutils">
<dt>::</dt>
<dd>&lt;:expr&lt; [] &gt;&gt;</dd>
</dl>
<p>and the fold function would be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>fun e1 e2 -&gt; &lt;:expr&lt; [$e1$ :: $e2$ ] &gt;&gt;
</pre></div>
</div>
<p>except that, implemented like that, they would return the list in  reverse order.</p>
<p>Actually, a program using them can be written with the lists iterators
with the semantic action applying the function <code class="docutils literal"><span class="pre">List.fold_left</span></code> to
the returned list, except that with the fold iterators, this operation
is done as long as the symbols are read on the input, no intermediate
list being built.</p>
<p>Example, file <code class="docutils literal"><span class="pre">sum.ml</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#load &quot;pa_extend.cmo&quot;;
#load &quot;pa_extfold.cmo&quot;;
#load &quot;q_MLast.cmo&quot;;
let loc = Ploc.dummy in
EXTEND
  Pcaml.expr:
    [ [ &quot;sum&quot;;
        e =
          FOLD0 (fun e1 e2 -&gt; &lt;:expr&lt; $e2$ + $e1$ &gt;&gt;) &lt;:expr&lt; 0 &gt;&gt;
            Pcaml.expr SEP &quot;;&quot;;
        &quot;end&quot; -&gt; e ] ]
  ;
END;
</pre></div>
</div>
<p>which can be compiled like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlc</span> <span class="o">-</span><span class="n">pp</span> <span class="n">camlp5r</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span><span class="n">camlp5</span> <span class="o">-</span><span class="n">c</span> <span class="nb">sum</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>and tested:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocaml</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span><span class="n">camlp5</span> <span class="n">camlp5r</span><span class="o">.</span><span class="n">cma</span> <span class="nb">sum</span><span class="o">.</span><span class="n">cmo</span>
        <span class="n">Objective</span> <span class="n">Caml</span> <span class="n">version</span> <span class="o">...</span>

        <span class="n">Camlp5</span> <span class="n">Parsing</span> <span class="n">version</span> <span class="o">...</span>

<span class="c1"># sum 3;4;5 end;</span>
<span class="o">-</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
</div>
<div class="section" id="grammar-machinery">
<span id="grammars-machinery"></span><h3>Grammar machinery<a class="headerlink" href="#grammar-machinery" title="Permalink to this headline">¶</a></h3>
<p>We explain here the detail of the mechanism of the parsing of an
entry.</p>
<div class="section" id="start-and-continue">
<h4>Start and Continue<a class="headerlink" href="#start-and-continue" title="Permalink to this headline">¶</a></h4>
<p>At each entry level, the rules are separated into two trees:</p>
<ul class="simple">
<li>The tree of the rules <em>not</em> starting with the current entry name nor
by <code class="docutils literal"><span class="pre">SELF</span></code>.</li>
<li>The tree of the rules starting with the current entry name or by the
identifier <code class="docutils literal"><span class="pre">SELF</span></code>, this symbol not being included in the tree.</li>
</ul>
<p>They determine two functions:</p>
<ul class="simple">
<li>The function named “start”, analyzing the first tree.</li>
<li>The function named “continue”, taking, as parameter, a value
previously parsed, and analyzing the second tree.</li>
</ul>
<p>A call to an entry, using <code class="docutils literal"><span class="pre">Grammar.Entry.parse</span></code> correspond to a call
to the “start” function of the first level of the entry.</p>
<p>The “start” function tries its associated tree. If it works, it calls
the “continue” function of the same level, giving the result of
“start” as parameter. If this “continue” function fails, this
parameter is simply returned. If the “start” function fails, the
“start” function of the next level is tested. If there is no more
levels, the parsing fails.</p>
<p>The “continue” function first tries the “continue” function of the
next level. If it fails, or if it is the last level, it tries its
associated tree, then calls itself again, giving the result as
parameter. If its associated tree fails, it returns its extra
parameter.</p>
</div>
<div class="section" id="associativity">
<h4>Associativity<a class="headerlink" href="#associativity" title="Permalink to this headline">¶</a></h4>
<p>While testing the tree, there is a special case for rules ending with
SELF or with the current entry name. For this last symbol, there is a
call to the “start” function: of the current level if the level is
right associative, or of the next level otherwise.</p>
<p>There is no behaviour difference between left and non associative,
because, in case of syntax error, the system attempts to recover the
error by applying the “continue” function of the previous symbol (if
this symbol is a call to an entry).</p>
<p>When a SELF or the current entry name is encountered in the middle of
the rule (i.e. if it is not the last symbol), there is a call to the
“start” function of the first level of the current entry.</p>
<p>Example. Let us consider the following grammar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">EXTEND</span>
  <span class="n">expr</span><span class="p">:</span>
    <span class="p">[</span> <span class="s2">&quot;minus&quot;</span> <span class="n">LEFTA</span>
      <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">SELF</span><span class="p">;</span> <span class="s2">&quot;-&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SELF</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">-.</span> <span class="n">y</span> <span class="p">]</span>
    <span class="o">|</span> <span class="s2">&quot;power&quot;</span> <span class="n">RIGHTA</span>
      <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">SELF</span><span class="p">;</span> <span class="s2">&quot;**&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SELF</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">**</span> <span class="n">y</span> <span class="p">]</span>
    <span class="o">|</span> <span class="s2">&quot;simple&quot;</span>
      <span class="p">[</span> <span class="s2">&quot;(&quot;</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">SELF</span><span class="p">;</span> <span class="s2">&quot;)&quot;</span> <span class="o">-&gt;</span> <span class="n">x</span>
      <span class="o">|</span> <span class="n">x</span> <span class="o">=</span> <span class="n">INT</span> <span class="o">-&gt;</span> <span class="n">float_of_int</span> <span class="n">x</span> <span class="p">]</span> <span class="p">]</span>
  <span class="p">;</span>
<span class="n">END</span>
</pre></div>
</div>
<p>The left “SELF”s of the two levels “minus” and “power” correspond to a
call to the next level. In the level “minus”, the right “SELF” also,
and the left associativity is treated by the fact that the “continue”
function is called (starting with the keyword “-” since the left
“SELF” is not part of the tree). On the other hand, for the level
“power”, the right “SELF” corresponds to a call to the current level,
i.e. the level “power” again. At end, the “SELF” between parentheses
of the level “simple” correspond to a call to the first level, namely
“minus” in this grammar.</p>
</div>
<div class="section" id="parsing-algorithm">
<h4>Parsing algorithm<a class="headerlink" href="#parsing-algorithm" title="Permalink to this headline">¶</a></h4>
<p>By default, the kind of grammar is predictive parsing grammar,
i.e. recursive descent parsing without backtrack. But with some
nuances, due to the improvements (error recovery and token starting
rules) indicated in the next sections.</p>
<p>However, it is possible to change the parsing algorithm, by calling
the function <code class="docutils literal"><span class="pre">Grammar.set_algorithm</span></code>. The possible values are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Grammar.Predictive</span></code>: internally using <a class="reference internal" href="#parsers"><span class="std std-ref">Stream parsers</span></a>, with
a predictive (recursive descent without backtracking) algorithm.</li>
<li><code class="docutils literal"><span class="pre">Grammar.Functional</span></code>: internally using <a class="reference internal" href="#fparsers"><span class="std std-ref">Functional parsers</span></a>,
with a limited backtracking algorithm,</li>
<li><code class="docutils literal"><span class="pre">Grammar.Backtracking</span></code>: internally using
<a class="reference internal" href="#bparsers"><span class="std std-ref">Backtracking parsers</span></a>, with a full backtracking algorithm,</li>
<li><code class="docutils literal"><span class="pre">Grammar.DefaultAlgorithm</span></code>: the parsing algorithm is determined by
the environment variable <code class="docutils literal"><span class="pre">CAMLP5PARAM</span></code>. If this environment variable
exists and contains <code class="docutils literal"><span class="pre">f</span></code>, the parsing algorithm is “functional”; if
it it <code class="docutils literal"><span class="pre">b</span></code>, the parsing algorithm is “backtracking”. Otherwise it is
“predictive”.</li>
</ul>
<p>An interesting function, when using then backtracking algorithm, is
<code class="docutils literal"><span class="pre">Grammar.Entry.parse_all</span></code> which returns all solutions of a given
input.</p>
</div>
<div class="section" id="errors-and-recovery">
<h4>Errors and recovery<a class="headerlink" href="#errors-and-recovery" title="Permalink to this headline">¶</a></h4>
<p>In extensible grammars, the exceptions are encapsulated with the
exception “Ploc.Exc” giving the location of the error together with
the exception itself.</p>
<p>If the parsing algorithm is <code class="docutils literal"><span class="pre">Grammar.Predictive</span></code>, the system
internally uses <a class="reference internal" href="#parsers"><span class="std std-ref">Stream parsers</span></a>. Two exceptions may happen:
<code class="docutils literal"><span class="pre">Stream.Failure</span></code> or <code class="docutils literal"><span class="pre">Stream.Error</span></code>. <code class="docutils literal"><span class="pre">Stream.Failure</span></code> indicates
that the parsing just could not start. <code class="docutils literal"><span class="pre">Stream.Error</span></code> indicates that
the parsing started but failed further.</p>
<p>With this algorithm, when the first symbol of a rule has been
accepted, all the symbols of the same rule must be accepted, otherwise
the exception <code class="docutils literal"><span class="pre">Stream.Error</span></code> is raised.</p>
<p>If the parsing algorithm is <code class="docutils literal"><span class="pre">Grammar.Functional</span></code> (resp.
<code class="docutils literal"><span class="pre">Grammar.Backtracking</span></code>), the system internally uses
<a class="reference internal" href="#fparsers"><span class="std std-ref">Functional parsers</span></a> (resp <a class="reference internal" href="#bparsers"><span class="std std-ref">Backtracking parsers</span></a>). If no
solution is found, the exception <code class="docutils literal"><span class="pre">Stream.Error</span></code> is raised and the
location of the error is the location of the last unfrozen token,
i.e. where the stream advanced the farthest.</p>
<p>In extensible grammars, unlike stream parsers, before the
<code class="docutils literal"><span class="pre">Stream.Error</span></code> exception, the system attempts to recover the error
by the following trick: if the previous symbol of the rule was a call
to another entry, the system calls the “continue” function of that
entry, which may resolve the problem.</p>
</div>
<div class="section" id="tokens-starting-rules">
<h4>Tokens starting rules<a class="headerlink" href="#tokens-starting-rules" title="Permalink to this headline">¶</a></h4>
<p>Another improvement (other than error recovery) is that when a rule
starts with several tokens and/or keywords, all these tokens and
keywords are tested in one time, and the possible <code class="docutils literal"><span class="pre">Stream.Error</span></code> may
happen, only from the symbol following them on, if any.</p>
</div>
</div>
<div class="section" id="interface-with-the-lexer">
<h3>Interface with the lexer<a class="headerlink" href="#interface-with-the-lexer" title="Permalink to this headline">¶</a></h3>
<p>To create a grammar, the function <code class="docutils literal"><span class="pre">Grammar.gcreate</span></code> must be called,
with a lexer as parameter.</p>
<p>A simple solution, as possible lexer, is the predefined lexer built by
<code class="docutils literal"><span class="pre">Plexer.gmake</span> <span class="pre">()</span></code>, lexer used for the OCaml grammar of Camlp5. In
this case, you can just put it as parameter of <code class="docutils literal"><span class="pre">Grammar.gcreate</span></code> and
it is not necessary to read this section.</p>
<p>The section first introduces the notion of “token patterns” which are
the way the tokens and keywords symbols in the EXTEND statement are
represented. Then follow the description of the type of the parameter
of <code class="docutils literal"><span class="pre">Grammar.gcreate</span></code>.</p>
<div class="section" id="token-patterns">
<h4>Token patterns<a class="headerlink" href="#token-patterns" title="Permalink to this headline">¶</a></h4>
<p>A token pattern is a value of the type defined like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">pattern</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span> <span class="o">*</span> <span class="n">string</span><span class="p">);</span>
</pre></div>
</div>
<p>This type represents values of the token and keywords symbols in the
grammar rules.</p>
<p>For a token symbol in the grammar rules, the first string is the token
constructor name (starting with an uppercase character), the second
string indicates whether the match is “any” (the empty string) or some
specific value of the token (an non-empty string).</p>
<p>For a keyword symbol, the first string is empty and the second string
is the keyword itself.</p>
<p>For example, given this grammar rule:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;for&quot;</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LIDENT</span><span class="p">;</span> <span class="s2">&quot;=&quot;</span><span class="p">;</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">SELF</span><span class="p">;</span> <span class="s2">&quot;to&quot;</span><span class="p">;</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">SELF</span>
</pre></div>
</div>
<p>the different symbols and keywords are represented by the following
pairs of strings:</p>
<ul class="simple">
<li>the keyword “for” is represented by <code class="docutils literal"><span class="pre">(&quot;&quot;,</span> <span class="pre">&quot;for&quot;)</span></code>,</li>
<li>the keyword “=” by <code class="docutils literal"><span class="pre">(&quot;&quot;,</span> <span class="pre">&quot;=&quot;)</span></code>,</li>
<li>the keyword “to” by <code class="docutils literal"><span class="pre">(&quot;&quot;,</span> <span class="pre">&quot;to&quot;)</span></code>),</li>
<li>and the token symbol <code class="docutils literal"><span class="pre">LIDENT</span></code> by <code class="docutils literal"><span class="pre">(&quot;LIDENT&quot;,</span> <span class="pre">&quot;&quot;)</span></code>.</li>
</ul>
<p>The symbol <code class="docutils literal"><span class="pre">UIDENT</span> <span class="pre">&quot;Foo&quot;</span></code> in a rule would be represented by the
token pattern:</p>
<dl class="docutils">
<dt>::</dt>
<dd>(“UIDENT”, “Foo”)</dd>
</dl>
<p>Notice that the symbol <code class="docutils literal"><span class="pre">SELF</span></code> is a specific symbol of the EXTEND
syntax: it does not correspond to a token pattern and is represented
differently. A token constructor name must not belong to the specific
symbols: SELF, NEXT, LIST0, LIST1, OPT and FLAG.</p>
</div>
<div class="section" id="the-lexer-record">
<h4>The lexer record<a class="headerlink" href="#the-lexer-record" title="Permalink to this headline">¶</a></h4>
<p>The type of the parameter of the function <code class="docutils literal"><span class="pre">Grammar.gcreate</span></code> is
<code class="docutils literal"><span class="pre">lexer</span></code>, defined in the module <code class="docutils literal"><span class="pre">Plexing</span></code>. It is a record type with
the following fields:</p>
<div class="section" id="tok-func">
<h5><code class="docutils literal"><span class="pre">tok_func</span></code><a class="headerlink" href="#tok-func" title="Permalink to this headline">¶</a></h5>
<p>It is the lexer itself. Its type is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Stream</span><span class="o">.</span><span class="n">t</span> <span class="n">char</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">t</span> <span class="p">(</span><span class="n">string</span> <span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="o">*</span> <span class="n">location_function</span><span class="p">);</span>
</pre></div>
</div>
<p>The lexer takes a character stream as parameter and return a couple of
containing: a token stream (the tokens being represented by a couple
of strings), and a location function.</p>
<p>The location function is a function taking, as parameter, a integer
corresponding to a token number in the stream (starting from zero),
and returning the location of this token in the source. This is
important to get good locations in the semantic actions of the grammar
rules.</p>
<p>Notice that, despite the lexer taking a character stream as parameter,
it is not mandatory to use the stream parsers technology to write the
lexer. What is important is that it does the job.</p>
</div>
<div class="section" id="tok-using">
<h5><code class="docutils literal"><span class="pre">tok_using</span></code><a class="headerlink" href="#tok-using" title="Permalink to this headline">¶</a></h5>
<p>Is a function of type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">unit</span>
</pre></div>
</div>
<p>The parameter of this function is the representation of a token symbol
or a keyword symbol in grammar rules. See the section about token
patterns.</p>
<p>This function is called for each token symbol and each keyword
encountered in the grammar rules of the EXTEND statement. Its goal is
to allow the lexer to check that the tokens and keywords do respect
the lexer rules. It checks that the tokens exist and are not
mispelled. It can be also used to enter the keywords in the lexer
keyword tables.</p>
<p>Setting it as the function that does nothing is possible, but the
check of correctness of tokens is not done.</p>
<p>In case or error, the function must raise the exception
<code class="docutils literal"><span class="pre">Plexing.Error</span></code> with an error message as parameter.</p>
</div>
<div class="section" id="tok-removing">
<h5><code class="docutils literal"><span class="pre">tok_removing</span></code><a class="headerlink" href="#tok-removing" title="Permalink to this headline">¶</a></h5>
<p>Is a function of type:</p>
<dl class="docutils">
<dt>::</dt>
<dd>pattern -&gt; unit</dd>
</dl>
<p>It is possibly called by the DELETE_RULE statement for tokens and
keywords no longer used in the grammar. The grammar system maintains a
number of usages of all tokens and keywords and calls this function
only when this number reaches zero. This can be interesting for
keywords: the lexer can remove them from its tables.</p>
</div>
<div class="section" id="tok-match">
<h5><code class="docutils literal"><span class="pre">tok_match</span></code><a class="headerlink" href="#tok-match" title="Permalink to this headline">¶</a></h5>
<p>Is a function of type:</p>
<dl class="docutils">
<dt>::</dt>
<dd>pattern -&gt; ((string * string) -&gt; unit)</dd>
</dl>
<p>The function tells how a token of the input stream is matched against
a token pattern. Both are represented by a couple of strings.</p>
<p>This function takes a token pattern as parameter and return a function
matching a token, returning the matched string or raising the
exception <code class="docutils literal"><span class="pre">Stream.Failure</span></code> if the token does not match.</p>
<p>Notice that, for efficiency, it is necessary to write this function as
a match of token patterns returning, for each case, the function which
matches the token, &lt;em&gt;not&lt;/em&gt; a function matching the token pattern
and the token together and returning a string for each case.</p>
<p>An acceptable function is provided in the module <code class="docutils literal"><span class="pre">Plexing</span></code> and is
named “default_match”. Its code looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">default_match</span> <span class="o">=</span>
  <span class="n">fun</span>
  <span class="p">[</span> <span class="p">(</span><span class="n">p_con</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">prm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">con</span> <span class="o">=</span> <span class="n">p_con</span> <span class="n">then</span> <span class="n">prm</span> <span class="k">else</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span>
  <span class="o">|</span> <span class="p">(</span><span class="n">p_con</span><span class="p">,</span> <span class="n">p_prm</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">prm</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="n">con</span> <span class="o">=</span> <span class="n">p_con</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">prm</span> <span class="o">=</span> <span class="n">p_prm</span> <span class="n">then</span> <span class="n">prm</span> <span class="k">else</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
<span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="tok-text">
<h5><code class="docutils literal"><span class="pre">tok_text</span></code><a class="headerlink" href="#tok-text" title="Permalink to this headline">¶</a></h5>
<p>Is a function of type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">string</span>
</pre></div>
</div>
<p>Designed for error messages, it takes a token pattern as parameter and
returns the string giving its name.</p>
<p>It is possible to use the predefined function <code class="docutils literal"><span class="pre">lexer_text</span></code> of the
Plexing module. This function just returns the name of the token
pattern constructor and its parameter if any.</p>
<p>For example, with this default function, the token symbol IDENT would
be written as IDENT in error message (e.g. “IDENT expected”).  The
“text” function may decide to print it differently, e.g., as
“identifier”.</p>
</div>
<div class="section" id="tok-comm">
<h5><code class="docutils literal"><span class="pre">tok_comm</span></code><a class="headerlink" href="#tok-comm" title="Permalink to this headline">¶</a></h5>
<p>Is a mutable field of type:</p>
<dl class="docutils">
<dt>::</dt>
<dd>option (list location)</dd>
</dl>
<p>It asks the lexer (the lexer function should do it) to record the
locations of the comments in the program. Setting this field to
<code class="docutils literal"><span class="pre">None</span></code> indicates that the lexer must not record them. Setting it to
<code class="docutils literal"><span class="pre">Some</span> <span class="pre">[]</span></code> indicated that the lexer must put the comments location
list in the field, which is mutable.</p>
</div>
</div>
<div class="section" id="minimalist-version">
<h4>Minimalist version<a class="headerlink" href="#minimalist-version" title="Permalink to this headline">¶</a></h4>
<p>If a lexer have been written, named <code class="docutils literal"><span class="pre">lexer</span></code>, here is the minimalist
version of the value suitable as parameter to <code class="docutils literal"><span class="pre">Grammar.gcreate</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">Plexing</span><span class="o">.</span><span class="n">tok_func</span> <span class="o">=</span> <span class="n">lexer</span><span class="p">;</span>
 <span class="n">Plexing</span><span class="o">.</span><span class="n">tok_using</span> <span class="n">_</span> <span class="o">=</span> <span class="p">();</span> <span class="n">Plexing</span><span class="o">.</span><span class="n">tok_removing</span> <span class="n">_</span> <span class="o">=</span> <span class="p">();</span>
 <span class="n">Plexing</span><span class="o">.</span><span class="n">tok_match</span> <span class="o">=</span> <span class="n">Plexing</span><span class="o">.</span><span class="n">default_match</span><span class="p">;</span>
 <span class="n">Plexing</span><span class="o">.</span><span class="n">tok_text</span> <span class="o">=</span> <span class="n">Plexing</span><span class="o">.</span><span class="n">lexer_text</span><span class="p">;</span>
 <span class="n">Plexing</span><span class="o">.</span><span class="n">tok_comm</span> <span class="o">=</span> <span class="kc">None</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="functorial-interface">
<h3>Functorial interface<a class="headerlink" href="#functorial-interface" title="Permalink to this headline">¶</a></h3>
<p>The normal interface for grammars described in the previous sections
has two drawbacks:</p>
<ul class="simple">
<li>First, the type of tokens of the lexers must be <code class="docutils literal"><span class="pre">(string</span> <span class="pre">*</span>
<span class="pre">string)</span></code></li>
<li>Second, since the entry type has no parameter to specify the grammar
it is bound to, there is no static check that entries are
compatible, i.e.  belong to the same grammar. The check is done at
run time.</li>
</ul>
<p>The functorial interface resolve these two problems. The functor takes
a module as parameter where the token type has to be defined, together
with the lexer returning streams of tokens of this type. The resulting
module define entries compatible the ones to the other, and this is
controlled by the OCaml type checker.</p>
<p>The syntax extension must be done with the statement GEXTEND, instead
of EXTEND, and deletion by GDELETE_RULE instead of DELETE_RULE.</p>
<div class="section" id="the-lexer-type">
<h4>The lexer type<a class="headerlink" href="#the-lexer-type" title="Permalink to this headline">¶</a></h4>
<p>In the section about the interface with the lexer, we presented the
<code class="docutils literal"><span class="pre">Plexing.lexer</span></code> type as a record without type parameter. Actually,
this type is defined as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">lexer</span> <span class="s1">&#39;te =</span>
  <span class="p">{</span> <span class="n">tok_func</span> <span class="p">:</span> <span class="n">lexer_func</span> <span class="s1">&#39;te;</span>
    <span class="n">tok_using</span> <span class="p">:</span> <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">unit</span><span class="p">;</span>
    <span class="n">tok_removing</span> <span class="p">:</span> <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">unit</span><span class="p">;</span>
    <span class="n">tok_match</span> <span class="p">:</span> <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="s1">&#39;te -&gt; string;</span>
    <span class="n">tok_text</span> <span class="p">:</span> <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">string</span><span class="p">;</span>
    <span class="n">tok_comm</span> <span class="p">:</span> <span class="n">mutable</span> <span class="n">option</span> <span class="p">(</span><span class="nb">list</span> <span class="n">location</span><span class="p">)</span> <span class="p">}</span>
<span class="p">;</span>
</pre></div>
</div>
<p>where the type parameter is the type of the token, which can be any
type, different from <code class="docutils literal"><span class="pre">(string</span> <span class="pre">*</span> <span class="pre">string)</span></code>, providing the lexer
function (<code class="docutils literal"><span class="pre">tok_func</span></code>) returns a stream of this token type and the
match function (<code class="docutils literal"><span class="pre">tok_match</span></code>) indicates how to match values of this
token type against the token patterns (which remain defined as
<code class="docutils literal"><span class="pre">(string</span> <span class="pre">*</span> <span class="pre">string)</span></code>).</p>
<p>Here is an example of an user token type and the associated match
function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">mytoken</span> <span class="o">=</span>
  <span class="p">[</span> <span class="n">Ident</span> <span class="n">of</span> <span class="n">string</span>
  <span class="o">|</span> <span class="n">Int</span> <span class="n">of</span> <span class="nb">int</span>
  <span class="o">|</span> <span class="n">Comma</span> <span class="o">|</span> <span class="n">Equal</span>
  <span class="o">|</span> <span class="n">Keyw</span> <span class="n">of</span> <span class="n">string</span>  <span class="p">]</span>
<span class="p">;</span>

<span class="n">value</span> <span class="n">mymatch</span> <span class="o">=</span>
  <span class="n">fun</span>
  <span class="p">[</span> <span class="p">(</span><span class="s2">&quot;IDENT&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">[</span> <span class="n">Ident</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
  <span class="o">|</span> <span class="p">(</span><span class="s2">&quot;INT&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">[</span> <span class="n">Int</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">string_of_int</span> <span class="n">i</span> <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
  <span class="o">|</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">[</span> <span class="n">Comma</span> <span class="o">-&gt;</span> <span class="s2">&quot;&quot;</span> <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
  <span class="o">|</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">[</span> <span class="n">Equal</span> <span class="o">-&gt;</span> <span class="s2">&quot;&quot;</span> <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
  <span class="o">|</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span>
      <span class="p">[</span> <span class="n">Keyw</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">k</span> <span class="o">=</span> <span class="n">s</span> <span class="n">then</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span>
      <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="p">(</span><span class="n">Plexing</span><span class="o">.</span><span class="n">Error</span> <span class="s2">&quot;bad token in match function&quot;</span><span class="p">)</span> <span class="p">]</span>
<span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="the-functor-parameter">
<h4>The functor parameter<a class="headerlink" href="#the-functor-parameter" title="Permalink to this headline">¶</a></h4>
<p>The type of the functor parameter is defined as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="nb">type</span> <span class="n">GLexerType</span> <span class="o">=</span>
  <span class="n">sig</span>
    <span class="nb">type</span> <span class="n">te</span> <span class="o">=</span> <span class="s1">&#39;x;</span>
    <span class="n">value</span> <span class="n">lexer</span> <span class="p">:</span> <span class="n">Plexing</span><span class="o">.</span><span class="n">lexer</span> <span class="n">te</span><span class="p">;</span>
  <span class="n">end</span><span class="p">;</span>
</pre></div>
</div>
<p>The token type must be specified (type <code class="docutils literal"><span class="pre">te</span></code>) and the lexer also,
with the interface for lexers, of the lexer type defined above, the
record fields being described in the section “interface with the
lexer”, but with a general token type.</p>
</div>
<div class="section" id="the-resulting-grammar-module">
<h4>The resulting grammar module<a class="headerlink" href="#the-resulting-grammar-module" title="Permalink to this headline">¶</a></h4>
<p>Once a module of type <code class="docutils literal"><span class="pre">GLexerType</span></code> has been built (previous
section), it is possible to create a grammar module by applying the
functor <code class="docutils literal"><span class="pre">Grammar.GMake</span></code>. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">MyGram</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">GMake</span> <span class="n">MyLexer</span><span class="p">;</span>
</pre></div>
</div>
<p>Notice that the function <code class="docutils literal"><span class="pre">Entry.parse</span></code> of this resulting module does
not take a character stream as parameter, but a value of type
<code class="docutils literal"><span class="pre">parsable</span></code>. This function is equivalent to the function
<code class="docutils literal"><span class="pre">parse_parsable</span></code> of the non functorial interface. In short, the
parsing of some character stream <code class="docutils literal"><span class="pre">cs</span></code> by some entry <code class="docutils literal"><span class="pre">e</span></code> of the
example grammar above, must be done by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MyGram</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">parse</span> <span class="n">e</span> <span class="p">(</span><span class="n">MyGram</span><span class="o">.</span><span class="n">parsable</span> <span class="n">cs</span><span class="p">)</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MyGram</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">parse</span> <span class="n">e</span> <span class="n">cs</span>
</pre></div>
</div>
</div>
<div class="section" id="gextend-and-gdelete-rule">
<h4>GEXTEND and GDELETE_RULE<a class="headerlink" href="#gextend-and-gdelete-rule" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">GEXTEND</span></code> and <code class="docutils literal"><span class="pre">GDELETE_RULE</span></code> statements are also added in the
expressions of the OCaml language when the syntax extension kit
<code class="docutils literal"><span class="pre">pa_extend.cmo</span></code> is loaded. They must be used for grammars defined
with the functorial interface. Their syntax is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>         <span class="n">expression</span> <span class="p">::</span><span class="o">=</span> <span class="n">gextend</span>
                      <span class="o">|</span> <span class="n">gdelete</span><span class="o">-</span><span class="n">rule</span>
       <span class="n">gdelete</span><span class="o">-</span><span class="n">rule</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;GDELETE_RULE&quot;</span> <span class="n">gdelete</span><span class="o">-</span><span class="n">rule</span><span class="o">-</span><span class="n">body</span> <span class="s2">&quot;END&quot;</span>
            <span class="n">gextend</span> <span class="p">::</span><span class="o">=</span> <span class="s2">&quot;GEXTEND&quot;</span> <span class="n">gextend</span><span class="o">-</span><span class="n">body</span> <span class="s2">&quot;END&quot;</span>
       <span class="n">gextend</span><span class="o">-</span><span class="n">body</span> <span class="p">::</span><span class="o">=</span> <span class="n">grammar</span><span class="o">-</span><span class="n">module</span><span class="o">-</span><span class="n">name</span> <span class="n">extend</span><span class="o">-</span><span class="n">body</span>
  <span class="n">gdelete</span><span class="o">-</span><span class="n">rule</span><span class="o">-</span><span class="n">body</span> <span class="p">::</span><span class="o">=</span> <span class="n">grammar</span><span class="o">-</span><span class="n">module</span><span class="o">-</span><span class="n">name</span> <span class="n">delete</span><span class="o">-</span><span class="n">rule</span><span class="o">-</span><span class="n">body</span>
<span class="n">grammar</span><span class="o">-</span><span class="n">module</span><span class="o">-</span><span class="n">name</span> <span class="p">::</span><span class="o">=</span> <span class="n">qualid</span>
</pre></div>
</div>
<p>See the syntax of the EXTEND statement for the meaning of the syntax
entries not defined above.</p>
</div>
</div>
<div class="section" id="an-example-arithmetic-calculator">
<h3>An example: arithmetic calculator<a class="headerlink" href="#an-example-arithmetic-calculator" title="Permalink to this headline">¶</a></h3>
<p>Here is a small calculator of expressions. They are given as
parameters of the command.</p>
<p>File “calc.ml”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#load &quot;pa_extend.cmo&quot;;</span>

<span class="n">value</span> <span class="n">g</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">gcreate</span> <span class="p">(</span><span class="n">Plexer</span><span class="o">.</span><span class="n">gmake</span> <span class="p">());</span>
<span class="n">value</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">create</span> <span class="n">g</span> <span class="s2">&quot;expression&quot;</span><span class="p">;</span>

<span class="n">EXTEND</span>
  <span class="n">e</span><span class="p">:</span>
    <span class="p">[</span> <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="s2">&quot;+&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
      <span class="o">|</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="s2">&quot;-&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="p">]</span>
    <span class="o">|</span> <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="s2">&quot;*&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
      <span class="o">|</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="s2">&quot;/&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span> <span class="p">]</span>
    <span class="o">|</span> <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">INT</span> <span class="o">-&gt;</span> <span class="n">int_of_string</span> <span class="n">x</span>
      <span class="o">|</span> <span class="s2">&quot;(&quot;</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="s2">&quot;)&quot;</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="p">]</span> <span class="p">]</span>
  <span class="p">;</span>
<span class="n">END</span><span class="p">;</span>

<span class="nb">open</span> <span class="n">Printf</span><span class="p">;</span>

<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">Array</span><span class="o">.</span><span class="n">length</span> <span class="n">Sys</span><span class="o">.</span><span class="n">argv</span> <span class="o">-</span> <span class="mi">1</span> <span class="n">do</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">parse</span> <span class="n">e</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">of_string</span> <span class="n">Sys</span><span class="o">.</span><span class="n">argv</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="ow">in</span>
  <span class="n">printf</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">Sys</span><span class="o">.</span><span class="n">argv</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">r</span><span class="p">;</span>
  <span class="n">flush</span> <span class="n">stdout</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Linking needs the library <code class="docutils literal"><span class="pre">gramlib.cma</span></code> provided with Camlp5:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlc</span> <span class="o">-</span><span class="n">pp</span> <span class="n">camlp5r</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span><span class="n">camlp5</span> <span class="n">gramlib</span><span class="o">.</span><span class="n">cma</span> <span class="n">test</span><span class="o">/</span><span class="n">calc</span><span class="o">.</span><span class="n">ml</span> <span class="o">-</span><span class="n">o</span> <span class="n">calc</span>
</pre></div>
</div>
<p>Examples:</p>
<dl class="docutils">
<dt>::</dt>
<dd>$ ./calc ‘239*4649’
239*4649 = 1111111
$ ./calc ‘(47+2)/3’
(47+2)/3 = 16</dd>
</dl>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="prtools.html" class="btn btn-neutral float-right" title="Printing tools" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pptools.html" class="btn btn-neutral" title="Parsing and Printing tools" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Daniel de Rauglaudre.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'7.10',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>